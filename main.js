/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CoherencePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian33 = require("obsidian");

// src/ui/atomizer-modal.ts
var import_obsidian2 = require("obsidian");

// src/modules/atomizer.ts
var import_obsidian = require("obsidian");
var AtomizerService = class {
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Sanitize a string to be safe for filenames
   */
  sanitize(name) {
    let cleaned = name.replace(/[<>:"/\\|?*\n\r\t]/g, "_");
    cleaned = cleaned.replace(/_{2,}/g, "_");
    cleaned = cleaned.replace(/^_+|_+$/g, "").trim();
    return cleaned || "untitled";
  }
  /**
   * Generate a unique path if file already exists
   */
  async getUniquePath(folder, name) {
    const base = (0, import_obsidian.normalizePath)(`${folder}/${name}.md`);
    if (!await this.vault.adapter.exists(base)) {
      return base;
    }
    let counter = 2;
    while (counter < 1e3) {
      const candidate = (0, import_obsidian.normalizePath)(`${folder}/${name}-${counter}.md`);
      if (!await this.vault.adapter.exists(candidate)) {
        return candidate;
      }
      counter++;
    }
  }
  /**
   * Helper to create the output directory
   */
  async createOutputDirectory(file) {
    const atomizedDir = (0, import_obsidian.normalizePath)(`${file.parent.path}/Atomized`);
    if (!await this.vault.adapter.exists(atomizedDir)) {
      await this.vault.createFolder(atomizedDir);
    }
    const rootDir = (0, import_obsidian.normalizePath)(`${atomizedDir}/${file.basename}`);
    if (!await this.vault.adapter.exists(rootDir)) {
      await this.vault.createFolder(rootDir);
    }
    return rootDir;
  }
  /**
   * Helper to extract YAML and Intro content
   */
  extractPreamble(lines) {
    const yaml = [];
    const remainingLines = [];
    let inYaml = false;
    let startIndex = 0;
    if (lines.length > 0 && lines[0].trim() === "---") {
      inYaml = true;
      yaml.push(lines[0]);
      startIndex = 1;
    }
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i];
      if (inYaml) {
        yaml.push(line);
        if (line.trim() === "---") {
          inYaml = false;
        }
      } else {
        remainingLines.push(line);
      }
    }
    return { yaml, intro: [], remainingLines };
  }
  /**
   * Atomize by Heading
   */
  async atomizeByHeading(file) {
    const content = await this.vault.read(file);
    const lines = content.split("\n");
    const rootDir = await this.createOutputDirectory(file);
    const { yaml, remainingLines } = this.extractPreamble(lines);
    const headingRegex = /^(#{1,6})[ \t]+(.+?)\s*$/;
    const intro = [];
    const sections = [];
    let current = null;
    for (const line of remainingLines) {
      const match = line.match(headingRegex);
      if (match) {
        if (current) {
          sections.push(current);
        }
        current = {
          level: match[1].length,
          title: match[2].trim(),
          content: []
        };
      } else {
        if (current) {
          current.content.push(line);
        } else {
          intro.push(line);
        }
      }
    }
    if (current) {
      sections.push(current);
    }
    if (yaml.length > 0 || intro.some((l) => l.trim())) {
      const preambleContent = [...yaml, ...intro].join("\n");
      if (preambleContent.trim().length > 0) {
        await this.vault.create(
          (0, import_obsidian.normalizePath)(`${rootDir}/preamble.md`),
          preambleContent
        );
      }
    }
    const stack = [];
    for (const section of sections) {
      while (stack.length > 0 && stack[stack.length - 1].level >= section.level) {
        stack.pop();
      }
      const parentPath = stack.length > 0 ? stack[stack.length - 1].path : rootDir;
      const safeTitle = this.sanitize(section.title);
      const sectionDir = `${parentPath}/${safeTitle}`;
      if (!await this.vault.adapter.exists(sectionDir)) {
        await this.vault.createFolder(sectionDir);
      }
      const filePath = `${sectionDir}/${safeTitle}.md`;
      await this.vault.create(
        (0, import_obsidian.normalizePath)(filePath),
        section.content.join("\n").trim()
      );
      stack.push({ level: section.level, path: sectionDir });
    }
  }
  /**
   * Atomize by ISO Date
   */
  async atomizeByDate(file) {
    const content = await this.vault.read(file);
    const lines = content.split("\n");
    const rootDir = await this.createOutputDirectory(file);
    const { yaml, remainingLines } = this.extractPreamble(lines);
    const dateRegex = /\d{4}-\d{2}-\d{2}/;
    const intro = [];
    const sections = [];
    let currentTitle = null;
    let currentBlock = [];
    for (const line of remainingLines) {
      if (dateRegex.test(line)) {
        if (currentTitle) {
          sections.push({ title: currentTitle, content: currentBlock });
        } else if (currentBlock.length > 0) {
          intro.push(...currentBlock);
        }
        currentTitle = line.trim();
        currentBlock = [];
        currentBlock.push(line);
      } else {
        if (currentTitle) {
          currentBlock.push(line);
        } else {
          intro.push(line);
        }
      }
    }
    if (currentTitle) {
      sections.push({ title: currentTitle, content: currentBlock });
    } else if (currentBlock.length > 0) {
      intro.push(...currentBlock);
    }
    if (yaml.length > 0 || intro.some((l) => l.trim())) {
      const preambleContent = [...yaml, ...intro].join("\n");
      if (preambleContent.trim().length > 0) {
        await this.vault.create(
          (0, import_obsidian.normalizePath)(`${rootDir}/preamble.md`),
          preambleContent
        );
      }
    }
    for (const section of sections) {
      const safeTitle = this.sanitize(section.title).substring(0, 80);
      const filePath = await this.getUniquePath(rootDir, safeTitle);
      await this.vault.create(filePath, section.content.join("\n").trim());
    }
  }
  /**
   * Atomize by Character (Divider)
   */
  async atomizeByDivider(file, divider = "---") {
    const content = await this.vault.read(file);
    const lines = content.split("\n");
    const rootDir = await this.createOutputDirectory(file);
    const { yaml, remainingLines } = this.extractPreamble(lines);
    const dividerRegex = new RegExp(`^\\s*${divider.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\s*$`);
    const intro = [];
    const sections = [];
    let currentBlock = [];
    let currentTitle = null;
    let needTitle = false;
    for (const line of remainingLines) {
      if (dividerRegex.test(line)) {
        if (currentTitle) {
          sections.push({ title: currentTitle, content: currentBlock });
        } else if (currentBlock.length > 0) {
          intro.push(...currentBlock);
        }
        currentTitle = null;
        currentBlock = [];
        needTitle = true;
      } else {
        if (needTitle && line.trim()) {
          currentTitle = line.trim();
          needTitle = false;
          currentBlock.push(line);
        } else if (currentTitle || needTitle) {
          currentBlock.push(line);
        } else {
          intro.push(line);
        }
      }
    }
    if (currentTitle || needTitle && currentBlock.length > 0) {
      sections.push({ title: currentTitle || "untitled", content: currentBlock });
    } else if (currentBlock.length > 0) {
      intro.push(...currentBlock);
    }
    if (yaml.length > 0 || intro.some((l) => l.trim())) {
      const preambleContent = [...yaml, ...intro].join("\n");
      if (preambleContent.trim().length > 0) {
        await this.vault.create(
          (0, import_obsidian.normalizePath)(`${rootDir}/preamble.md`),
          preambleContent
        );
      }
    }
    for (const section of sections) {
      let title = section.title;
      if (!title || title === "untitled") {
        const firstLine = section.content.find((l) => l.trim().length > 0);
        title = firstLine ? firstLine.substring(0, 50) : "untitled";
      }
      const safeTitle = this.sanitize(title);
      const filePath = await this.getUniquePath(rootDir, safeTitle);
      await this.vault.create(filePath, section.content.join("\n").trim());
    }
  }
};

// src/ui/atomizer-modal.ts
var AtomizerModal = class extends import_obsidian2.Modal {
  constructor(app, settings, target) {
    super(app);
    this.target = null;
    this.mode = "heading";
    this.divider = "---";
    this.service = new AtomizerService(app.vault);
    this.target = target != null ? target : this.app.workspace.getActiveFile();
    this.divider = settings.atomizerDivider || "---";
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    const isFolder = this.target instanceof import_obsidian2.TFolder;
    new import_obsidian2.Setting(contentEl).setName(isFolder ? `Atomize folder: ${(_a = this.target) == null ? void 0 : _a.name}` : "Atomize file").setHeading();
    new import_obsidian2.Setting(contentEl).setName("Atomization mode").setDesc("How to split the content").addDropdown((drop) => drop.addOption("heading", "By Heading").addOption("date", "By ISO Date").addOption("divider", "By Divider").setValue(this.mode).onChange((value) => {
      this.mode = value;
      this.display();
    }));
    if (this.mode === "divider") {
      new import_obsidian2.Setting(contentEl).setName("Divider string").setDesc("String to split on (e.g. ---)").addText((text) => text.setValue(this.divider).onChange((value) => this.divider = value));
    }
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText(isFolder ? "Atomize all files" : "Atomize").setCta().setDisabled(!this.target).onClick(async () => {
      if (this.target) {
        this.close();
        if (this.target instanceof import_obsidian2.TFolder) {
          new import_obsidian2.Notice(`Atomizing files in ${this.target.name}...`);
          let count = 0;
          for (const child of this.target.children) {
            if (child instanceof import_obsidian2.TFile && child.extension === "md") {
              try {
                await this.runAtomizer(child);
                count++;
              } catch (e) {
                console.error(`Failed to atomize ${child.name}`, e);
              }
            }
          }
          new import_obsidian2.Notice(`Atomization complete. Processed ${count} files.`);
        } else if (this.target instanceof import_obsidian2.TFile) {
          new import_obsidian2.Notice("Atomizing...");
          try {
            await this.runAtomizer(this.target);
            new import_obsidian2.Notice("Atomization complete.");
          } catch (e) {
            new import_obsidian2.Notice("Error during atomization.");
            console.error(e);
          }
        }
      }
    }));
  }
  async runAtomizer(file) {
    if (this.mode === "heading") {
      await this.service.atomizeByHeading(file);
    } else if (this.mode === "date") {
      await this.service.atomizeByDate(file);
    } else if (this.mode === "divider") {
      await this.service.atomizeByDivider(file, this.divider);
    }
  }
  display() {
    this.onOpen();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/summarizer-modal.ts
var import_obsidian5 = require("obsidian");

// src/modules/summarizer.ts
var import_obsidian3 = require("obsidian");
var SummarizerService = class {
  constructor(app, ollama) {
    this.app = app;
    this.ollama = ollama;
  }
  async summarizeFile(file, model, overwrite = false, prompts = [], generateTitle = false) {
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    let frontmatter = {};
    let body = content;
    if (match) {
      try {
        frontmatter = (0, import_obsidian3.parseYaml)(match[1]);
        body = content.substring(match[0].length).trim();
      } catch (e) {
        console.error("Failed to parse YAML", e);
      }
    }
    if (frontmatter.summary && !overwrite) {
      return false;
    }
    const defaultPrompt = "Please summarize the following markdown content. Keep it concise and capture the main points.";
    const activePrompts = prompts.filter((p) => p && p.trim().length > 0);
    if (activePrompts.length === 0) {
      activePrompts.push(defaultPrompt);
    }
    let currentText = body.substring(0, 5e4);
    let summary = "";
    try {
      for (const promptTemplate of activePrompts) {
        let prompt = promptTemplate.replace(/{filename}/g, file.basename).replace(/{text}/g, body.substring(0, 5e4)).replace(/{summary}/g, currentText);
        if (!promptTemplate.includes("{text}") && !promptTemplate.includes("{summary}")) {
          prompt = `${promptTemplate}

${currentText}`;
        }
        summary = await this.ollama.generate(model, prompt);
        currentText = summary;
      }
      frontmatter.summary = summary.trim();
      frontmatter["summary model"] = model;
      const newFrontmatter = `---
${(0, import_obsidian3.stringifyYaml)(frontmatter)}---
`;
      const newContent = newFrontmatter + body;
      await this.app.vault.modify(file, newContent);
      if (generateTitle) {
        try {
          const titlePrompt = `Output exactly one 3-12-word title (no digits, punctuation, list markers). Return only the title.

Abstract:
${summary}`;
          let newTitle = await this.ollama.generate(model, titlePrompt);
          newTitle = newTitle.replace(/[.@#%$&/\\<>\[\]():*?"|\n\r]/g, " ").trim();
          newTitle = newTitle.replace(/\s+/g, " ");
          if (newTitle.length > 0) {
            const newStem = `${file.basename} ${newTitle} AIG`;
            const newPath = `${file.parent.path}/${newStem}.md`;
            if (!await this.app.vault.adapter.exists(newPath)) {
              await this.app.fileManager.renameFile(file, newPath);
            } else {
              let i = 1;
              while (await this.app.vault.adapter.exists(`${file.parent.path}/${newStem} ${i}.md`)) {
                i++;
              }
              await this.app.fileManager.renameFile(file, `${file.parent.path}/${newStem} ${i}.md`);
            }
          }
        } catch (e) {
          console.error("Failed to generate title", e);
        }
      }
      return true;
    } catch (e) {
      console.error(`Failed to summarize ${file.path}`, e);
      throw e;
    }
  }
  async summarizeFolder(folderPath, model, recursive = true, overwrite = false, prompts = [], generateTitle = false, onProgress) {
    const files = [];
    const collectFiles = (path) => {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder && "children" in folder) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian3.TFile && child.extension === "md") {
            files.push(child);
          } else if (recursive && "children" in child) {
            collectFiles(child.path);
          }
        }
      }
    };
    collectFiles(folderPath);
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    const total = files.length;
    for (let i = 0; i < total; i++) {
      const file = files[i];
      if (onProgress) {
        onProgress(i + 1, total, file.name);
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
      try {
        const result = await this.summarizeFile(file, model, overwrite, prompts, generateTitle);
        if (result)
          processed++;
        else
          skipped++;
      } catch (e) {
        errors++;
      }
    }
    return { processed, skipped, errors };
  }
};

// src/modules/ollama.ts
var import_obsidian4 = require("obsidian");
var OllamaService = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  async listModels() {
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url: `${this.baseUrl}/api/tags`,
        method: "GET"
      });
      if (response.status === 200) {
        const data = response.json;
        return data.models.map((m) => m.name);
      }
      return [];
    } catch (e) {
      console.error("Failed to list models", e);
      return [];
    }
  }
  async getModels() {
    return this.listModels();
  }
  async generate(model, prompt, options) {
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url: `${this.baseUrl}/api/generate`,
        method: "POST",
        body: JSON.stringify({
          model,
          prompt,
          stream: false,
          ...options
        })
      });
      if (response.status === 200) {
        return response.json.response;
      }
      throw new Error(`Ollama API Error: ${response.status}`);
    } catch (e) {
      console.error("Ollama generation failed", e);
      throw e;
    }
  }
  async chat(model, messages, format, options) {
    try {
      const body = {
        model,
        messages,
        stream: false,
        ...options
      };
      if (format) {
        body.format = format;
      }
      const response = await (0, import_obsidian4.requestUrl)({
        url: `${this.baseUrl}/api/chat`,
        method: "POST",
        body: JSON.stringify(body)
      });
      if (response.status === 200) {
        return response.json.message.content;
      }
      throw new Error(`Ollama API Error: ${response.status}`);
    } catch (e) {
      console.error("Ollama chat failed", e);
      throw e;
    }
  }
};

// src/ui/summarizer-modal.ts
var import_obsidian6 = require("obsidian");
var SummarizerModal = class extends import_obsidian5.Modal {
  constructor(app, settings, saveSettings, target) {
    super(app);
    this.target = null;
    // TFile or TFolder
    this.targetPath = "/";
    this.models = [];
    this.ollama = new OllamaService(settings.ollamaUrl);
    this.service = new SummarizerService(app, this.ollama);
    this.service = new SummarizerService(app, this.ollama);
    this.saveSettings = saveSettings;
    this.target = target;
    this.selectedModel = settings.summarizerModel;
    this.recursive = settings.summarizerRecursive;
    this.overwrite = settings.summarizerOverwrite;
    this.includeYaml = settings.summarizerIncludeYaml;
    this.maxChars = settings.summarizerMaxChars;
    this.prompt = settings.summarizerPrompt;
    this.prompt2 = settings.summarizerPrompt2;
    this.prompt3 = settings.summarizerPrompt3;
    this.prompt4 = settings.summarizerPrompt4;
    this.generateTitle = settings.summarizerGenerateTitle;
    if (this.target) {
      this.targetPath = this.target.path;
    } else {
      const active = this.app.workspace.getActiveFile();
      this.targetPath = active ? active.parent.path : "/";
    }
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Summarize Files" });
    contentEl.createEl("p", { text: "Loading models..." });
    try {
      this.models = await this.ollama.listModels();
    } catch (e) {
      contentEl.createEl("p", { text: "Failed to load models. Is Ollama running?", cls: "error-text" });
    }
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Summarize Files" });
    new import_obsidian5.Setting(contentEl).setName("Ollama Model").addDropdown((drop) => {
      drop.addOption("", "Select a model");
      this.models.forEach((m) => drop.addOption(m, m));
      drop.setValue(this.selectedModel);
      drop.onChange(async (value) => {
        this.selectedModel = value;
        await this.saveSettings("summarizerModel", value);
      });
    });
    new import_obsidian5.Setting(contentEl).setName("Recursive").setDesc("Process subfolders (if target is folder)").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
    new import_obsidian5.Setting(contentEl).setName("Overwrite Existing").setDesc("Re-summarize files that already have a summary").addToggle((toggle) => toggle.setValue(this.overwrite).onChange((value) => this.overwrite = value));
    new import_obsidian5.Setting(contentEl).setName("Generate Title for Untitled").setDesc('Automatically rename "Untitled" files using AI generated title').addToggle((toggle) => toggle.setValue(this.generateTitle).onChange((value) => this.generateTitle = value));
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Start Summarization").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      const progressContainer = contentEl.createDiv();
      progressContainer.style.marginTop = "20px";
      const progressBarBg = progressContainer.createDiv();
      progressBarBg.style.width = "100%";
      progressBarBg.style.height = "10px";
      progressBarBg.style.backgroundColor = "var(--background-modifier-border)";
      progressBarBg.style.borderRadius = "5px";
      const progressBar = progressBarBg.createDiv();
      progressBar.style.width = "0%";
      progressBar.style.height = "100%";
      progressBar.style.backgroundColor = "var(--interactive-accent)";
      progressBar.style.borderRadius = "5px";
      progressBar.style.transition = "width 0.1s";
      const progressText = progressContainer.createDiv();
      progressText.style.marginTop = "5px";
      progressText.style.fontSize = "0.8em";
      progressText.style.color = "var(--text-muted)";
      progressText.setText(`Starting with model: ${this.selectedModel}...`);
      console.log("Summarizer using model:", this.selectedModel);
      const onProgress = (processed, total, currentFile) => {
        const percent = Math.floor(processed / total * 100);
        progressBar.style.width = `${percent}%`;
        progressText.setText(`Processing ${processed}/${total}: ${currentFile}`);
      };
      try {
        const prompts = [this.prompt, this.prompt2, this.prompt3, this.prompt4];
        const abstractFile = this.app.vault.getAbstractFileByPath(this.targetPath);
        if (abstractFile) {
          if ("extension" in abstractFile) {
            const result = await this.service.summarizeFile(
              abstractFile,
              this.selectedModel,
              this.overwrite,
              prompts,
              this.generateTitle
            );
            new import_obsidian6.Notice(result ? "Summary added." : "Skipped (exists).");
          } else {
            const result = await this.service.summarizeFolder(
              this.targetPath,
              this.selectedModel,
              this.recursive,
              this.overwrite,
              prompts,
              this.generateTitle,
              onProgress
            );
            new import_obsidian6.Notice(`Complete: ${result.processed} processed, ${result.skipped} skipped, ${result.errors} errors.`);
          }
        } else {
          new import_obsidian6.Notice("Invalid path.");
        }
        this.close();
      } catch (e) {
        new import_obsidian6.Notice("Error during summarization. Check console.");
        console.error(e);
        btn.setButtonText("Start Summarization").setDisabled(false);
        progressText.setText("Error occurred.");
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/wisdom-modal.ts
var import_obsidian8 = require("obsidian");

// src/modules/wisdom.ts
var import_obsidian7 = require("obsidian");
var WisdomService = class {
  constructor(vault, ollama) {
    this.vault = vault;
    this.ollama = ollama;
  }
  async getUniquePath(folder, name) {
    const base = (0, import_obsidian7.normalizePath)(`${folder}/${name}.md`);
    if (!await this.vault.adapter.exists(base)) {
      return base;
    }
    let counter = 2;
    while (counter < 1e3) {
      const candidate = (0, import_obsidian7.normalizePath)(`${folder}/${name}-${counter}.md`);
      if (!await this.vault.adapter.exists(candidate)) {
        return candidate;
      }
      counter++;
    }
  }
  async processFile(file, model, mode = "generalized", promptTemplate) {
    const content = await this.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    let frontmatter = {};
    let body = content;
    if (match) {
      try {
        frontmatter = (0, import_obsidian7.parseYaml)(match[1]);
        body = content.substring(match[0].length).trim();
      } catch (e) {
        console.error("Failed to parse YAML", e);
      }
    }
    if (file.basename.endsWith("_generalized") || file.basename.endsWith("_safe")) {
      return "Skipped (already processed)";
    }
    const outputFolder = (0, import_obsidian7.normalizePath)(`${file.parent.path}/Generalized`);
    if (!await this.vault.adapter.exists(outputFolder)) {
      await this.vault.createFolder(outputFolder);
    }
    let newContent = body;
    const suffix = mode === "safe" ? "_safe" : "_generalized";
    if (mode === "generalized") {
      const defaultPrompt = `
            You are a wisdom extractor. Rewrite the following personal text into general wisdom and insights.
            Rules:
            1. Remove all names, places, and identifying details.
            2. Focus on the lessons, insights, and universal truths.
            3. Maintain the emotional core but make it applicable to anyone.
            4. Return ONLY the rewritten text.
            `;
      const template = promptTemplate || defaultPrompt;
      const prompt = `${template}

Text:
${body.substring(0, 15e3)}`;
      try {
        newContent = await this.ollama.generate(model, prompt);
      } catch (e) {
        console.error("Wisdom extraction failed", e);
        throw e;
      }
    }
    frontmatter.original_file = `[[${file.basename}]]`;
    const newFileContent = `---
${(0, import_obsidian7.stringifyYaml)(frontmatter)}---

${newContent}`;
    const newFilename = `${file.basename}${suffix}`;
    const newPath = await this.getUniquePath(outputFolder, newFilename);
    await this.vault.create(newPath, newFileContent);
    return `Created ${newPath}`;
  }
  async processFolder(folderPath, model, mode = "generalized", promptTemplate) {
    const files = [];
    const collectFiles = (path) => {
      const folder = this.vault.getAbstractFileByPath(path);
      if (folder instanceof import_obsidian7.TFolder) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian7.TFile && child.extension === "md") {
            files.push(child);
          } else if ("children" in child) {
            collectFiles(child.path);
          }
        }
      }
    };
    collectFiles(folderPath);
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    for (const file of files) {
      try {
        const result = await this.processFile(file, model, mode, promptTemplate);
        if (result.startsWith("Created"))
          processed++;
        else
          skipped++;
      } catch (e) {
        errors++;
      }
    }
    return { processed, skipped, errors };
  }
};

// src/ui/wisdom-modal.ts
var WisdomModal = class extends import_obsidian8.Modal {
  constructor(app, settings, target) {
    super(app);
    this.target = null;
    this.models = [];
    this.ollama = new OllamaService(settings.ollamaUrl);
    this.service = new WisdomService(app.vault, this.ollama);
    this.target = target != null ? target : this.app.workspace.getActiveFile();
    this.selectedModel = settings.wisdomModel;
    this.mode = settings.wisdomMode;
    this.prompt = settings.wisdomPrompt;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian8.Setting(contentEl).setName("Wisdom extractor").setHeading();
    contentEl.createEl("p", { text: "Loading models..." });
    try {
      this.models = await this.ollama.listModels();
    } catch (e) {
      contentEl.createEl("p", { text: "Failed to load models.", cls: "error-text" });
    }
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian8.Setting(contentEl).setName("Wisdom extractor").setHeading();
    if (this.target) {
      const type = this.target instanceof import_obsidian8.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.target.name} (${type})` });
    } else {
      contentEl.createEl("p", { text: "No file or folder selected.", cls: "error-text" });
      return;
    }
    new import_obsidian8.Setting(contentEl).setName("Ollama model").addDropdown((drop) => {
      this.models.forEach((m) => drop.addOption(m, m));
      drop.setValue(this.selectedModel);
      drop.onChange((value) => this.selectedModel = value);
    });
    new import_obsidian8.Setting(contentEl).setName("Mode").setDesc("Generalized (AI Rewrite) or Safe (Copy as-is)").addDropdown((drop) => drop.addOption("generalized", "Generalized (AI)").addOption("safe", "Safe (Copy Only)").setValue(this.mode).onChange((value) => this.mode = value));
    new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText("Extract wisdom").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      try {
        if (this.target instanceof import_obsidian8.TFile) {
          const result = await this.service.processFile(
            this.target,
            this.selectedModel,
            this.mode,
            this.prompt
          );
          new import_obsidian8.Notice(result);
        } else {
          const result = await this.service.processFolder(
            this.target.path,
            this.selectedModel,
            this.mode,
            this.prompt
          );
          new import_obsidian8.Notice(`Batch Complete: ${result.processed} processed, ${result.skipped} skipped, ${result.errors} errors.`);
        }
        this.close();
      } catch (e) {
        new import_obsidian8.Notice("Error during extraction.");
        console.error(e);
        btn.setButtonText("Extract wisdom").setDisabled(false);
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/date-fix-modal.ts
var import_obsidian10 = require("obsidian");

// src/modules/date-fix.ts
var import_obsidian9 = require("obsidian");
var DateFixService = class {
  constructor(app) {
    this.app = app;
  }
  async fixDatesInFolder(folderPath, recursive, fallbackToCreationDate, dateFormat, exceptions) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let renamed = 0;
    let errors = 0;
    const exceptionList = exceptions.split(",").map((e) => e.trim()).filter((e) => e.length > 0);
    for (const file of files) {
      processed++;
      try {
        if (this.isException(file, exceptionList)) {
          continue;
        }
        const newName = await this.getNewFilename(file, fallbackToCreationDate, dateFormat);
        if (newName && newName !== file.name) {
          const newPath = (0, import_obsidian9.normalizePath)(`${file.parent ? file.parent.path : ""}/${newName}`);
          await this.app.fileManager.renameFile(file, newPath);
          renamed++;
        }
      } catch (e) {
        console.error(`Failed to process ${file.path}`, e);
        errors++;
      }
    }
    return { processed, renamed, errors };
  }
  async fixDateInFile(file, fallbackToCreationDate, dateFormat, exceptions) {
    try {
      const exceptionList = exceptions.split(",").map((e) => e.trim()).filter((e) => e.length > 0);
      if (this.isException(file, exceptionList)) {
        return "Skipped (Exception)";
      }
      const newName = await this.getNewFilename(file, fallbackToCreationDate, dateFormat);
      if (newName && newName !== file.name) {
        const newPath = (0, import_obsidian9.normalizePath)(`${file.parent ? file.parent.path : ""}/${newName}`);
        await this.app.fileManager.renameFile(file, newPath);
        return `Renamed to ${newName}`;
      }
      return "No change needed";
    } catch (e) {
      console.error(`Failed to process ${file.path}`, e);
      throw e;
    }
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian9.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian9.TFile) {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  isException(file, exceptions) {
    for (const exception of exceptions) {
      if (exception.startsWith("*.")) {
        const ext = exception.substring(2);
        if (file.extension === ext)
          return true;
      } else {
        if (file.name.includes(exception))
          return true;
      }
    }
    return false;
  }
  async getNewFilename(file, fallbackToCreationDate, dateFormat) {
    let name = file.name;
    if (/^\d{4}[-_]\d{2}[-_]\d{2}/.test(name)) {
      return name;
    }
    const datePattern = /(\d{4})(\d{2})(\d{2})([-_]\d{4,6})?/;
    const match = name.match(datePattern);
    if (match) {
      const year = match[1];
      const month = match[2];
      const day = match[3];
      const date = window.moment(`${year}-${month}-${day}`, "YYYY-MM-DD");
      if (date.isValid()) {
        const formattedDate = date.format(dateFormat);
        const extIndex = name.lastIndexOf(".");
        let baseName = name;
        let ext = "";
        if (extIndex > 0) {
          baseName = name.substring(0, extIndex);
          ext = name.substring(extIndex);
        }
        const matchBase = baseName.match(datePattern);
        if (matchBase) {
          const year2 = matchBase[1];
          const month2 = matchBase[2];
          const day2 = matchBase[3];
          const date2 = window.moment(`${year2}-${month2}-${day2}`, "YYYY-MM-DD");
          if (date2.isValid()) {
            let newBase = baseName.replace(matchBase[0], "").trim();
            newBase = newBase.replace(/^[-_ ]+|[-_ ]+$/g, "");
            newBase = newBase.replace(/[-_ ]{2,}/g, "_");
            if (newBase) {
              name = `${formattedDate}_${newBase}${ext}`;
            } else {
              name = `${formattedDate}${ext}`;
            }
            return name;
          }
        }
      }
    }
    if (fallbackToCreationDate) {
      const ctime = file.stat.ctime;
      const dateStr = window.moment(ctime).format(dateFormat);
      name = `${dateStr}_${name}`;
    }
    return name;
  }
};

// src/ui/date-fix-modal.ts
var DateFixModal = class extends import_obsidian10.Modal {
  constructor(app, settings, target) {
    super(app);
    this.target = null;
    this.recursive = true;
    this.fallbackToCreationDate = false;
    this.dateFormat = "YYYY-MM-DD";
    this.exceptions = "";
    this.service = new DateFixService(app.vault);
    this.target = target != null ? target : this.app.workspace.getActiveFile();
    this.recursive = settings.dateFixRecursive;
    this.fallbackToCreationDate = settings.dateFixFallbackToCreationDate;
    this.dateFormat = settings.dateFixDateFormat;
    this.exceptions = settings.dateFixExceptions;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian10.Setting(contentEl).setName("Date fix / rename").setHeading();
    if (this.target) {
      const type = this.target instanceof import_obsidian10.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.target.name} (${type})` });
    } else {
      contentEl.createEl("p", { text: "No file or folder selected.", cls: "error-text" });
      return;
    }
    new import_obsidian10.Setting(contentEl).setName("Recursive").setDesc("Process subfolders (if target is folder)").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
    new import_obsidian10.Setting(contentEl).setName("Fallback to creation date").setDesc("If no date is found in the filename, prepend the file's creation date.").addToggle((toggle) => toggle.setValue(this.fallbackToCreationDate).onChange((value) => this.fallbackToCreationDate = value));
    new import_obsidian10.Setting(contentEl).setName("Preferred date format").setDesc("ISO format to use (e.g. YYYY-MM-DD)").addText((text) => text.setValue(this.dateFormat).onChange((value) => this.dateFormat = value));
    new import_obsidian10.Setting(contentEl).setName("Exceptions").setDesc("Comma separated list of file extensions (e.g. *.py) or words to exclude").addTextArea((text) => text.setValue(this.exceptions).onChange((value) => this.exceptions = value));
    new import_obsidian10.Setting(contentEl).addButton((btn) => btn.setButtonText("Run date fix").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      try {
        if (this.target instanceof import_obsidian10.TFile) {
          const result = await this.service.fixDateInFile(this.target, this.fallbackToCreationDate, this.dateFormat, this.exceptions);
          new import_obsidian10.Notice(result);
        } else {
          const result = await this.service.fixDatesInFolder(
            this.target.path,
            this.recursive,
            this.fallbackToCreationDate,
            this.dateFormat,
            this.exceptions
          );
          new import_obsidian10.Notice(`Complete: ${result.processed} processed, ${result.renamed} renamed, ${result.errors} errors.`);
        }
        this.close();
      } catch (e) {
        new import_obsidian10.Notice("Error during date fix.");
        console.error(e);
        btn.setButtonText("Run date fix").setDisabled(false);
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/concatonizer-modal.ts
var import_obsidian12 = require("obsidian");

// src/modules/concatonizer.ts
var import_obsidian11 = require("obsidian");
var ConcatonizerService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async concatonizeFolder(folderPath, outputName, recursive, stripYaml, includeFilename) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    if (files.length === 0) {
      return "No markdown files found.";
    }
    let content = "";
    files.sort((a, b) => a.path.localeCompare(b.path));
    for (const file of files) {
      let fileContent = await this.vault.read(file);
      if (stripYaml) {
        fileContent = fileContent.replace(/^---\n[\s\S]*?\n---\n/, "");
      }
      const relPath = file.path.startsWith(folderPath) ? file.path.substring(folderPath.length + 1) : file.path;
      if (includeFilename) {
        content += `
# ${relPath}

`;
      }
      content += fileContent;
      content += `

`;
    }
    const outputPath = (0, import_obsidian11.normalizePath)(`${folderPath}/${outputName}`);
    if (await this.vault.adapter.exists(outputPath)) {
      const file = this.vault.getAbstractFileByPath(outputPath);
      if (file instanceof import_obsidian11.TFile) {
        await this.vault.modify(file, content);
      }
    } else {
      await this.vault.create(outputPath, content);
    }
    return `Combined ${files.length} files into ${outputName}`;
  }
  collectFiles(path, files, recursive) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian11.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian11.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
};

// src/ui/concatonizer-modal.ts
var ConcatonizerModal = class extends import_obsidian12.Modal {
  constructor(app, settings, target) {
    super(app);
    this.target = null;
    this.recursive = false;
    this.stripYaml = false;
    this.outputName = "combined.md";
    this.separator = "\n\n---\n\n";
    this.includeFilename = true;
    this.service = new ConcatonizerService(app.vault);
    this.target = target;
    this.recursive = settings.concatonizerRecursive;
    this.stripYaml = settings.concatonizerStripYaml;
    const suffix = settings.concatonizerSuffix || "_combined";
    if (this.target instanceof import_obsidian12.TFolder) {
      this.outputName = `${this.target.name}${suffix}.md`;
    } else if (this.target && this.target.parent) {
      this.outputName = `${this.target.parent.name}${suffix}.md`;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian12.Setting(contentEl).setName("Concatonizer").setHeading();
    if (!this.target || this.target instanceof import_obsidian12.TFile) {
      contentEl.createEl("p", { text: "Please select a folder to concatonize.", cls: "error-text" });
      if (this.target instanceof import_obsidian12.TFile) {
        this.target = this.target.parent;
        contentEl.createEl("p", { text: `Using parent folder: ${this.target.path}` });
      } else {
        return;
      }
    } else {
      contentEl.createEl("p", { text: `Target Folder: ${this.target.path}` });
    }
    new import_obsidian12.Setting(contentEl).setName("Output filename").setDesc("Name of the combined file").addText((text) => text.setValue(this.outputName).onChange((value) => this.outputName = value));
    new import_obsidian12.Setting(contentEl).setName("Recursive").setDesc("Include subfolders").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
    new import_obsidian12.Setting(contentEl).setName("Strip YAML").setDesc("Remove YAML frontmatter from combined files").addToggle((toggle) => toggle.setValue(this.stripYaml).onChange((value) => this.stripYaml = value));
    new import_obsidian12.Setting(contentEl).setName("Include filename").setDesc("Add filename as header for each file content").addToggle((toggle) => toggle.setValue(this.includeFilename).onChange((value) => this.includeFilename = value));
    new import_obsidian12.Setting(contentEl).addButton((btn) => btn.setButtonText("Concatonize").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      try {
        const result = await this.service.concatonizeFolder(
          this.target.path,
          this.outputName,
          this.recursive,
          this.stripYaml,
          this.includeFilename
        );
        new import_obsidian12.Notice(result);
        this.close();
      } catch (e) {
        new import_obsidian12.Notice("Error during concatenation.");
        console.error(e);
        btn.setButtonText("Concatonize").setDisabled(false);
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/rating-modal.ts
var import_obsidian14 = require("obsidian");

// src/modules/rating.ts
var import_obsidian13 = require("obsidian");
var RatingService = class {
  constructor(app, ollama) {
    this.app = app;
    this.ollama = ollama;
  }
  async rateFile(file, model, qualityParams) {
    try {
      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      if ((cache == null ? void 0 : cache.frontmatter) && "auto rating" in cache.frontmatter) {
        return cache.frontmatter["auto rating"];
      }
      const rating = await this.getRatingFromAI(content, model, qualityParams);
      if (rating) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter["auto rating"] = rating;
        });
        return rating;
      }
      return null;
    } catch (e) {
      console.error(`Failed to rate file ${file.path}`, e);
      return null;
    }
  }
  async rateFolder(folderPath, model, qualityParams, recursive, skipExisting, onProgress) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let rated = 0;
    let errors = 0;
    const total = files.length;
    for (let i = 0; i < total; i++) {
      const file = files[i];
      if (onProgress) {
        onProgress(i + 1, total, file.name);
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
      processed++;
      try {
        if (skipExisting) {
          const cache = this.app.metadataCache.getFileCache(file);
          if ((cache == null ? void 0 : cache.frontmatter) && "auto rating" in cache.frontmatter) {
            continue;
          }
        }
        const rating = await this.rateFile(file, model, qualityParams);
        if (rating)
          rated++;
      } catch (e) {
        errors++;
      }
    }
    return { processed, rated, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder && "children" in folder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian13.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  async getRatingFromAI(text, model, qualityParams) {
    const paramsText = qualityParams.join(", ");
    const systemPrompt = `You are a writing quality evaluator.
Rate the quality of writing based on: ${paramsText}.

Rating scale:
1 - Very poor quality (lacks coherence, shallow, poorly written)
2 - Poor quality (some coherence issues, limited depth, needs improvement)
3 - Average quality (adequate coherence, moderate depth, acceptable writing)
4 - Good quality (strong coherence, good depth, well-written)
5 - Excellent quality (exceptional coherence, profound depth, outstanding writing)

Consider all specified quality parameters when assigning the rating.
Return JSON only, matching the given schema, with a single integer rating from 1-5.`;
    const schema = {
      "type": "object",
      "properties": {
        "rating": {
          "type": "integer",
          "minimum": 1,
          "maximum": 5,
          "description": "Rating from 1 (lowest) to 5 (highest)"
        }
      },
      "required": ["rating"],
      "additionalProperties": false
    };
    try {
      const response = await this.ollama.chat(model, [
        { role: "system", content: systemPrompt },
        { role: "user", content: text }
      ], schema, { temperature: 0 });
      const data = JSON.parse(response);
      return data.rating;
    } catch (e) {
      console.error("AI Rating failed", e);
      return null;
    }
  }
};

// src/ui/rating-modal.ts
var RatingModal = class extends import_obsidian14.Modal {
  constructor(app, settings, saveSettings, target) {
    var _a;
    super(app);
    this.recursive = false;
    this.skipExisting = true;
    this.models = [];
    this.ollama = new OllamaService(settings.ollamaUrl);
    this.service = new RatingService(app, this.ollama);
    this.saveSettings = saveSettings;
    this.target = target || app.workspace.getActiveFile();
    this.model = settings.ratingModel || "llama3.1";
    this.params = settings.ratingParams || "coherence, profundity";
    this.skipExisting = (_a = settings.ratingSkipIfRated) != null ? _a : true;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Automatic Rating" });
    contentEl.createEl("p", { text: "Loading models..." });
    try {
      this.models = await this.ollama.listModels();
    } catch (e) {
      contentEl.createEl("p", { text: "Failed to load models. Is Ollama running?", cls: "error-text" });
    }
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Automatic Rating" });
    if (this.target) {
      const type = this.target.extension ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.target.name} (${type})` });
    } else {
      contentEl.createEl("p", { text: `No target selected. (Target is ${this.target})`, cls: "error-text" });
      return;
    }
    new import_obsidian14.Setting(contentEl).setName("Model").addDropdown((drop) => {
      drop.addOption("", "Select a model");
      this.models.forEach((m) => drop.addOption(m, m));
      if (!this.models.includes(this.model)) {
        drop.addOption(this.model, this.model);
      }
      drop.setValue(this.model);
      drop.onChange(async (value) => {
        this.model = value;
        await this.saveSettings("ratingModel", value);
      });
    });
    new import_obsidian14.Setting(contentEl).setName("Quality Parameters").setDesc("Comma separated list").addText((text) => text.setValue(this.params).onChange((v) => this.params = v));
    if (!this.target.extension) {
      new import_obsidian14.Setting(contentEl).setName("Recursive").addToggle((t) => t.setValue(this.recursive).onChange((v) => this.recursive = v));
    }
    new import_obsidian14.Setting(contentEl).setName("Skip Existing").setDesc("Skip files that already have a rating").addToggle((t) => t.setValue(this.skipExisting).onChange((v) => this.skipExisting = v));
    new import_obsidian14.Setting(contentEl).addButton((btn) => btn.setButtonText("Start Rating").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      const params = this.params.split(",").map((p) => p.trim()).filter((p) => p);
      const progressContainer = contentEl.createDiv();
      progressContainer.style.marginTop = "20px";
      const progressBarBg = progressContainer.createDiv();
      progressBarBg.style.width = "100%";
      progressBarBg.style.height = "10px";
      progressBarBg.style.backgroundColor = "var(--background-modifier-border)";
      progressBarBg.style.borderRadius = "5px";
      const progressBar = progressBarBg.createDiv();
      progressBar.style.width = "0%";
      progressBar.style.height = "100%";
      progressBar.style.backgroundColor = "var(--interactive-accent)";
      progressBar.style.borderRadius = "5px";
      progressBar.style.transition = "width 0.1s";
      const progressText = progressContainer.createDiv();
      progressText.style.marginTop = "5px";
      progressText.style.fontSize = "0.8em";
      progressText.style.color = "var(--text-muted)";
      progressText.setText("Starting...");
      const onProgress = (processed, total, currentFile) => {
        const percent = Math.floor(processed / total * 100);
        progressBar.style.width = `${percent}%`;
        progressText.setText(`Processing ${processed}/${total}: ${currentFile}`);
      };
      try {
        if (this.target.extension) {
          const rating = await this.service.rateFile(this.target, this.model, params);
          new import_obsidian14.Notice(rating ? `Rated: ${rating}` : "Failed to rate");
        } else {
          const res = await this.service.rateFolder(this.target.path, this.model, params, this.recursive, this.skipExisting, onProgress);
          new import_obsidian14.Notice(`Processed: ${res.processed}, Rated: ${res.rated}, Errors: ${res.errors}`);
        }
        this.close();
      } catch (e) {
        new import_obsidian14.Notice("Error during rating");
        console.error(e);
        btn.setButtonText("Start Rating").setDisabled(false);
        progressText.setText("Error occurred.");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/deduplication-modal.ts
var import_obsidian16 = require("obsidian");

// src/modules/deduplication.ts
var import_obsidian15 = require("obsidian");
var crypto = __toESM(require("crypto"));
var DeduplicationService = class {
  constructor(app) {
    this.app = app;
  }
  async findDuplicatesInFolder(folderPath, recursive) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    return this.processFiles(files);
  }
  async compareFolders(folderA, folderB, recursive) {
    const filesA = [];
    const filesB = [];
    this.collectFiles(folderA, filesA, recursive);
    this.collectFiles(folderB, filesB, recursive);
    const mapA = await this.hashFiles(filesA);
    const mapB = await this.hashFiles(filesB);
    const duplicates = [];
    for (const [hash, groupA] of mapA.entries()) {
      const groupB = mapB.get(hash);
      if (groupB) {
        duplicates.push({
          hash,
          size: groupA[0].stat.size,
          files: [...groupA, ...groupB]
        });
      }
    }
    return duplicates;
  }
  async processFiles(files) {
    const hashMap = await this.hashFiles(files);
    const duplicates = [];
    for (const [hash, group] of hashMap.entries()) {
      if (group.length > 1) {
        duplicates.push({
          hash,
          size: group[0].stat.size,
          files: group
        });
      }
    }
    return duplicates;
  }
  async hashFiles(files) {
    var _a;
    const hashMap = /* @__PURE__ */ new Map();
    for (const file of files) {
      try {
        const content = await this.app.vault.readBinary(file);
        const hash = this.calculateHash(content);
        if (!hashMap.has(hash)) {
          hashMap.set(hash, []);
        }
        (_a = hashMap.get(hash)) == null ? void 0 : _a.push(file);
      } catch (e) {
        console.error(`Failed to hash file ${file.path}`, e);
      }
    }
    return hashMap;
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian15.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian15.TFile) {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  calculateHash(content) {
    const hash = crypto.createHash("md5");
    hash.update(Buffer.from(content));
    return hash.digest("hex");
  }
  async deleteFile(file) {
    await this.app.fileManager.trashFile(file);
  }
};

// src/ui/deduplication-modal.ts
var DeduplicationModal = class extends import_obsidian16.Modal {
  constructor(app, target) {
    super(app);
    // State
    this.searchScope = "folder";
    this.folderA = "";
    this.folderB = "";
    this.recursive = true;
    this.duplicates = null;
    this.service = new DeduplicationService(app);
    this.target = target;
    if (target instanceof import_obsidian16.TFolder) {
      this.folderA = target.path;
    } else if (target instanceof import_obsidian16.TFile && target.parent) {
      this.folderA = target.parent.path;
    }
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian16.Setting(contentEl).setName("Deduplication").setHeading();
    if (!this.duplicates) {
      this.renderSettings(contentEl);
    } else {
      this.renderResults(contentEl);
    }
  }
  renderSettings(contentEl) {
    new import_obsidian16.Setting(contentEl).setName("Scope").setDesc("Where to search for duplicates").addDropdown((drop) => drop.addOption("vault", "Entire Vault").addOption("folder", "Single Folder").addOption("two-folders", "Compare Two Folders").setValue(this.searchScope).onChange((v) => {
      this.searchScope = v;
      this.display();
    }));
    if (this.searchScope === "folder") {
      new import_obsidian16.Setting(contentEl).setName("Folder").addText((text) => text.setValue(this.folderA).setPlaceholder("Example: Folder/Subfolder").onChange((v) => this.folderA = v));
    } else if (this.searchScope === "two-folders") {
      new import_obsidian16.Setting(contentEl).setName("Folder A").addText((text) => text.setValue(this.folderA).setPlaceholder("Example: Folder/A").onChange((v) => this.folderA = v));
      new import_obsidian16.Setting(contentEl).setName("Folder B").addText((text) => text.setValue(this.folderB).setPlaceholder("Example: Folder/B").onChange((v) => this.folderB = v));
    }
    new import_obsidian16.Setting(contentEl).setName("Recursive").setDesc("Search in subfolders").addToggle((t) => t.setValue(this.recursive).onChange((v) => this.recursive = v));
    new import_obsidian16.Setting(contentEl).addButton((btn) => btn.setButtonText("Find duplicates").setCta().onClick(async () => {
      btn.setButtonText("Scanning...").setDisabled(true);
      try {
        if (this.searchScope === "vault") {
          this.duplicates = await this.service.findDuplicatesInFolder("/", this.recursive);
        } else if (this.searchScope === "folder") {
          this.duplicates = await this.service.findDuplicatesInFolder(this.folderA, this.recursive);
        } else {
          this.duplicates = await this.service.compareFolders(this.folderA, this.folderB, this.recursive);
        }
        this.display();
      } catch (e) {
        new import_obsidian16.Notice("Error finding duplicates");
        console.error(e);
        btn.setButtonText("Find duplicates").setDisabled(false);
      }
    }));
  }
  renderResults(contentEl) {
    var _a, _b, _c;
    if (((_a = this.duplicates) == null ? void 0 : _a.length) === 0) {
      contentEl.createEl("p", { text: "No duplicates found." });
      new import_obsidian16.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
      return;
    }
    contentEl.createEl("p", { text: `Found ${(_b = this.duplicates) == null ? void 0 : _b.length} groups of duplicates.` });
    const container = contentEl.createDiv({ cls: "dedup-results coherence-dedup-container" });
    (_c = this.duplicates) == null ? void 0 : _c.forEach((group, index) => {
      const groupEl = container.createDiv({ cls: "dedup-group coherence-dedup-group" });
      const header = groupEl.createDiv({ cls: "dedup-header coherence-dedup-header" });
      header.createEl("strong", { text: `Group ${index + 1}` });
      header.createSpan({ text: ` (Size: ${this.formatSize(group.size)})`, cls: "text-muted" });
      const filesContainer = groupEl.createDiv({ cls: "dedup-files coherence-dedup-files" });
      group.files.forEach((file) => {
        var _a2;
        const fileCard = filesContainer.createDiv({ cls: "dedup-file-card coherence-dedup-card" });
        fileCard.createEl("div", { text: file.name, cls: "file-name" });
        fileCard.createEl("div", { text: ((_a2 = file.parent) == null ? void 0 : _a2.path) || "/", cls: "file-path text-muted" });
        void this.app.vault.read(file).then((content) => {
          fileCard.createEl("div", {
            text: content.substring(0, 100) + "...",
            cls: "file-preview coherence-file-preview"
          });
        });
        const actions = fileCard.createDiv({ cls: "file-actions coherence-file-actions" });
        new import_obsidian16.Setting(actions).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(async () => {
          var _a3, _b2;
          await this.service.deleteFile(file);
          const fileIdx = group.files.indexOf(file);
          if (fileIdx > -1)
            group.files.splice(fileIdx, 1);
          if (group.files.length < 2) {
            const groupIdx = (_a3 = this.duplicates) == null ? void 0 : _a3.indexOf(group);
            if (groupIdx !== void 0 && groupIdx > -1) {
              (_b2 = this.duplicates) == null ? void 0 : _b2.splice(groupIdx, 1);
            }
          }
          this.display();
        }));
        new import_obsidian16.Setting(actions).addButton((btn) => btn.setButtonText("Open").onClick(() => {
          void this.app.workspace.getLeaf().openFile(file);
        }));
      });
      const groupActions = groupEl.createDiv({ cls: "group-actions coherence-group-actions" });
      new import_obsidian16.Setting(groupActions).addButton((btn) => btn.setButtonText("Skip group").onClick(() => {
        var _a2, _b2;
        const groupIdx = (_a2 = this.duplicates) == null ? void 0 : _a2.indexOf(group);
        if (groupIdx !== void 0 && groupIdx > -1) {
          (_b2 = this.duplicates) == null ? void 0 : _b2.splice(groupIdx, 1);
          this.display();
        }
      }));
    });
  }
  formatSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/parse-and-move-modal.ts
var import_obsidian18 = require("obsidian");

// src/modules/parse-and-move.ts
var import_obsidian17 = require("obsidian");
var ParseAndMoveService = class {
  constructor(app) {
    this.app = app;
  }
  async parseFile(file, categories) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const categorizedContent = {};
    let currentCategories = [];
    for (const category of Object.keys(categories)) {
      categorizedContent[category] = "";
    }
    for (const line of lines) {
      const lineWithoutEnd = line.replace("#ABC", "");
      let processedLine = lineWithoutEnd.replace(/\r$/, "");
      for (const [category, startTag] of Object.entries(categories)) {
        if (processedLine.includes(startTag)) {
          processedLine = processedLine.replace(startTag, "").trim();
          if (!currentCategories.includes(category)) {
            currentCategories.push(category);
          }
        }
      }
      if (currentCategories.length > 0) {
        for (const cat of currentCategories) {
          categorizedContent[cat] += processedLine + "\n";
        }
      }
      if (line.includes("#ABC")) {
        currentCategories = [];
      }
    }
    for (const category of Object.keys(categorizedContent)) {
      categorizedContent[category] = categorizedContent[category].trim();
    }
    return categorizedContent;
  }
  async processFile(file, categories, outputDir, shouldMove, targetDir) {
    const categorizedContent = await this.parseFile(file, categories);
    let hasContent = false;
    if (!await this.app.vault.adapter.exists(outputDir)) {
      await this.app.vault.createFolder(outputDir);
    }
    for (const [category, content] of Object.entries(categorizedContent)) {
      if (content.trim()) {
        hasContent = true;
        const categoryDir = (0, import_obsidian17.normalizePath)(`${outputDir}/${category}`);
        if (!await this.app.vault.adapter.exists(categoryDir)) {
          await this.app.vault.createFolder(categoryDir);
        }
        const outputFile = (0, import_obsidian17.normalizePath)(`${categoryDir}/${file.name}`);
        let existingContent = "";
        if (await this.app.vault.adapter.exists(outputFile)) {
          existingContent = await this.app.vault.adapter.read(outputFile);
          existingContent += "\n\n";
        }
        await this.app.vault.adapter.write(outputFile, existingContent + content);
      }
    }
    if (shouldMove && targetDir && hasContent) {
      for (const category of Object.keys(categorizedContent)) {
        if (categorizedContent[category].trim()) {
          const sourceFile = (0, import_obsidian17.normalizePath)(`${outputDir}/${category}/${file.name}`);
          const targetCategoryDir = (0, import_obsidian17.normalizePath)(`${targetDir}/${category}/Resources`);
          if (!await this.app.vault.adapter.exists(targetCategoryDir)) {
            await this.app.vault.createFolder(targetCategoryDir);
          }
          const targetFile = (0, import_obsidian17.normalizePath)(`${targetCategoryDir}/${file.name}`);
          if (await this.app.vault.adapter.exists(sourceFile)) {
            await this.app.vault.adapter.rename(sourceFile, targetFile);
          }
        }
      }
    }
  }
  async processFolder(folderPath, targetDir, recursive) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let moved = 0;
    let errors = 0;
    const categories = {
      "Resources": "## Resources",
      "Thoughts": "## Thoughts",
      "Questions": "## Questions"
    };
    for (const file of files) {
      try {
        await this.processFile(file, categories, targetDir, true, targetDir);
        moved++;
      } catch (e) {
        console.error(`Error processing ${file.path}`, e);
        errors++;
      }
    }
    return { moved, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian17.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian17.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
};

// src/ui/parse-and-move-modal.ts
var ParseAndMoveModal = class extends import_obsidian18.Modal {
  constructor(app, settings, fileOrFolder) {
    super(app);
    this.fileOrFolder = fileOrFolder;
    this.targetFolder = null;
    this.outputDir = "Categorized Content";
    this.targetDir = "";
    this.categoriesText = "";
    this.shouldMove = false;
    this.DEFAULT_CATEGORIES = `ADV - Adventure Hikes and Special Areas: #ADV
AI - Artificial Intelligence: #AI
AUT - Automotive and Equipment: #AUT
BOO - Book Media and Travel Suggestions: #BOO
CHE - Checklists: #CHE
CHI - Children and Parenting: #CHI
COH - Coherence: #COH
COM - Comedy: #COM
DAN - Dance: #DAN
DRA - Drawings: #DRA
DRE - Dreams: #DRE
ELE - Elegant Definitions: #ELE
FLWP - Followup: #FLWP
GC - General Contracting: #GC
HEA - Health: #HEA
HHH - Happy Healthy Home: #HHH
OGT - How I Organize Thought: #OGT
IDE - Ideas Meditations Thoughts and Inventions: #IDE
INT - Intuitive Happenings: #INT
LOV - Things I Love: #LOV
MAR - Marketing and Persuasion: #MAR
MED - Medicine Experience: #MED
MEM - Memoir Reflections: #MEM
MUS - Music: #MUS
NAT - Nature Musings and Spirituality: #NAT
NMO - Good Ideas Not My Own: #NMO
NW - New Words: #NW
ORG - Organizing People and Hosting: #ORG
PAR - Parenting and Children: #PAR
WOR - Words: #WOR
Mellisa: #PEO/Mellisa
Zev: #PEO/Zev
Grandma: #PEO/GMA
LuAnn: #PEO/LuAnn
Chenoa: #PEO/Chenoa
Eva: #PEO/Eva
Adrian: #PEO/Adrian
Maitreya: #PEO/Maitreya
Karma: #PEO/Karma
Meriwether: #PEO/Meriwether
Michael: #PEO/Michael
PM - Project Management: #PM
POE - Poetry: #POE
PP - Personal Principles and Constitution: #PP
PRO - Product Research: #PRO
REL - Relationships Romance and Sex: #REL
SCH - School: #SCH
SCU - Sculpture: #SCU
STO - Story Video Article and Book Ideas: #STO
STW - Save The World: #STW
SUC - Success and Creativity: #SUC
TAO - Tao Te Ching: #TAO
TEA - Teaching: #TEA
THE - Therapy: #THE
THR - Three Words: #THR
WRI - Writing Career: #WRI`;
    this.service = new ParseAndMoveService(app);
    this.categoriesText = this.DEFAULT_CATEGORIES;
    this.targetDir = settings.parseAndMoveTargetDir;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian18.Setting(contentEl).setName("Parse and move").setHeading();
    if (this.fileOrFolder) {
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path}` });
    } else {
      new import_obsidian18.Setting(contentEl).setName("Target folder").setDesc("Select the folder to parse (leave empty for root)").addText((text) => text.setPlaceholder("Example: Folder/Subfolder").onChange((value) => {
        const folder = this.app.vault.getAbstractFileByPath(value);
        if (folder instanceof import_obsidian18.TFolder) {
          this.targetFolder = folder;
        } else {
          this.targetFolder = null;
        }
      }));
    }
    new import_obsidian18.Setting(contentEl).setName("Output directory").setDesc("Directory where categorized files will be created").addText((text) => text.setValue(this.outputDir).onChange((value) => this.outputDir = value));
    new import_obsidian18.Setting(contentEl).setName("Move to target directory").setDesc("If enabled, files will be moved from Output Directory to Target Directory/Category/Resources").addToggle((toggle) => toggle.setValue(this.shouldMove).onChange((value) => {
      this.shouldMove = value;
      this.display();
    }));
    if (this.shouldMove) {
      new import_obsidian18.Setting(contentEl).setName("Target directory").setDesc("Final destination for categorized files").addText((text) => text.setValue(this.targetDir).onChange((value) => this.targetDir = value));
    }
    new import_obsidian18.Setting(contentEl).setName("Categories").setDesc("Format: Category Name: #Tag").addTextArea((text) => text.setValue(this.categoriesText).setPlaceholder("Category: #TAG").onChange((value) => this.categoriesText = value).inputEl.rows = 10);
    new import_obsidian18.Setting(contentEl).addButton((btn) => btn.setButtonText("Parse").setCta().onClick(() => this.parse()));
  }
  display() {
    this.onOpen();
  }
  async parse() {
    const folder = this.fileOrFolder instanceof import_obsidian18.TFolder ? this.fileOrFolder : this.fileOrFolder instanceof import_obsidian18.TFile ? this.fileOrFolder.parent : this.targetFolder || this.app.vault.getRoot();
    if (!folder) {
      new import_obsidian18.Notice("Invalid folder selected");
      return;
    }
    const categories = this.parseCategories(this.categoriesText);
    const files = this.getFiles(folder);
    new import_obsidian18.Notice(`Parsing ${files.length} files...`);
    this.close();
    let processedCount = 0;
    for (const file of files) {
      await this.service.processFile(file, categories, this.outputDir, this.shouldMove, this.targetDir);
      processedCount++;
    }
    new import_obsidian18.Notice(`Parsed ${processedCount} files.`);
  }
  getFiles(folder) {
    let files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian18.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian18.TFolder) {
        files = files.concat(this.getFiles(child));
      }
    }
    return files;
  }
  parseCategories(text) {
    const categories = {};
    const lines = text.split("\n");
    for (const line of lines) {
      const parts = line.split(":");
      if (parts.length >= 2) {
        const key = parts[0].trim();
        const value = parts.slice(1).join(":").trim();
        if (key && value) {
          categories[key] = value;
        }
      }
    }
    return categories;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/censor-modal.ts
var import_obsidian20 = require("obsidian");

// src/modules/censor.ts
var import_obsidian19 = require("obsidian");
var CensorService = class {
  constructor(app) {
    this.app = app;
  }
  async processFile(file, dictionary, direction, useMasking, sentenceLevel, outputMode, suffix, replacementChar = "\u2588") {
    const content = await this.app.vault.read(file);
    const { text: newContent, count } = this.applyPatterns(content, dictionary, direction, useMasking, sentenceLevel, replacementChar);
    if (count > 0) {
      let targetPath;
      if (outputMode === "folder") {
        const parentPath = file.parent ? file.parent.path : "/";
        const parentDir = parentPath === "/" ? "" : parentPath;
        const outputDir = (0, import_obsidian19.normalizePath)(`${parentDir}/Censored`);
        await this.ensureFolderExists(outputDir);
        targetPath = (0, import_obsidian19.normalizePath)(`${outputDir}/${file.basename}${suffix}.${file.extension}`);
      } else {
        const parentPath = file.parent ? file.parent.path : "/";
        const parentDir = parentPath === "/" ? "" : parentPath;
        targetPath = (0, import_obsidian19.normalizePath)(`${parentDir}/${file.basename}${suffix}.${file.extension}`);
      }
      if (await this.app.vault.adapter.exists(targetPath)) {
        const existing = this.app.vault.getAbstractFileByPath(targetPath);
        if (existing instanceof import_obsidian19.TFile) {
          await this.app.vault.modify(existing, newContent);
        }
      } else {
        await this.app.vault.create(targetPath, newContent);
      }
    }
  }
  async censorFolder(folderPath, keys, replacementChar, recursive, outputMode, suffix) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let errors = 0;
    const dictionary = keys.split("\n").filter((k) => k.trim()).map((k) => ({
      variants: [k.trim()],
      alias: "CENSORED"
    }));
    const useMasking = true;
    for (const file of files) {
      try {
        await this.processFile(
          file,
          dictionary,
          "forward",
          useMasking,
          false,
          outputMode,
          suffix,
          replacementChar
        );
        processed++;
      } catch (e) {
        console.error(`Error censoring ${file.path}`, e);
        errors++;
      }
    }
    return { processed, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian19.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian19.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  async ensureFolderExists(path) {
    const folders = path.split("/");
    let currentPath = "";
    for (const folder of folders) {
      if (!folder)
        continue;
      currentPath = currentPath === "" ? folder : `${currentPath}/${folder}`;
      if (!await this.app.vault.adapter.exists(currentPath)) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  applyPatterns(text, dictionary, direction, useMasking, sentenceLevel, replacementChar = "\u2588") {
    let totalCount = 0;
    if (direction === "reverse") {
      let processedText = text;
      for (const { variants, alias } of dictionary) {
        if (variants.length > 0) {
          const canonical = variants[0];
          const regex = this.termToRegex(alias);
          processedText = processedText.replace(regex, () => {
            totalCount++;
            return canonical;
          });
        }
      }
      return { text: processedText, count: totalCount };
    }
    if (sentenceLevel && useMasking) {
      const matches = [];
      for (const { variants } of dictionary) {
        for (const variant of variants) {
          const regex = this.termToRegex(variant);
          let match;
          while ((match = regex.exec(text)) !== null) {
            totalCount++;
            const sentRange = this.findSentenceRange(text, match.index);
            matches.push(sentRange);
          }
        }
      }
      if (matches.length === 0)
        return { text, count: 0 };
      matches.sort((a, b) => a.start - b.start);
      const merged = [];
      if (matches.length > 0) {
        let current = matches[0];
        for (let i = 1; i < matches.length; i++) {
          const next = matches[i];
          if (next.start <= current.end) {
            current.end = Math.max(current.end, next.end);
          } else {
            merged.push(current);
            current = next;
          }
        }
        merged.push(current);
      }
      let result = "";
      let lastIndex = 0;
      for (const range of merged) {
        result += text.substring(lastIndex, range.start);
        const len = range.end - range.start;
        result += replacementChar.repeat(len);
        lastIndex = range.end;
      }
      result += text.substring(lastIndex);
      return { text: result, count: totalCount };
    } else {
      let processedText = text;
      const allVariants = dictionary.flatMap((d) => d.variants.map((v) => ({ v, alias: d.alias })));
      allVariants.sort((a, b) => b.v.length - a.v.length);
      for (const { v, alias } of allVariants) {
        const regex = this.termToRegex(v);
        processedText = processedText.replace(regex, (match) => {
          totalCount++;
          return useMasking ? replacementChar.repeat(match.length) : alias;
        });
      }
      return { text: processedText, count: totalCount };
    }
  }
  termToRegex(term) {
    const escaped = term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/ /g, "\\s+");
    return new RegExp(`(?<!\\w)${escaped}(?!\\w)`, "gi");
  }
  findSentenceRange(text, matchIndex) {
    var _a, _b;
    const prefix = text.substring(0, matchIndex);
    const suffix = text.substring(matchIndex);
    let sentStart = 0;
    const boundaryRegex = /([.?!])(\s+)|(\n)/g;
    let m;
    while ((m = boundaryRegex.exec(prefix)) !== null) {
      sentStart = m.index + m[0].length;
    }
    const endRegex = /([.?!])(?=\s|$)|(\n)/;
    const endMatch = suffix.match(endRegex);
    let sentEnd = text.length;
    if (endMatch) {
      if (endMatch[0] === "\n") {
        sentEnd = matchIndex + ((_a = endMatch.index) != null ? _a : 0);
      } else {
        sentEnd = matchIndex + ((_b = endMatch.index) != null ? _b : 0) + 1;
      }
    }
    return { start: sentStart, end: sentEnd };
  }
};

// src/ui/censor-modal.ts
var CensorModal = class extends import_obsidian20.Modal {
  constructor(app, settings, fileOrFolder) {
    super(app);
    this.settings = settings;
    this.fileOrFolder = fileOrFolder;
    this.targetFolder = null;
    this.dictionaryText = "";
    this.direction = "forward";
    this.useMasking = false;
    this.sentenceLevel = false;
    this.recursive = false;
    this.service = new CensorService(app);
    this.selectedDictionaryName = settings.censorActiveDictionary;
    this.updateDictionaryText();
    this.recursive = settings.censorRecursive;
    if (this.settings.censorReplacementChar === "*") {
      this.settings.censorReplacementChar = "\u2588";
    }
  }
  updateDictionaryText() {
    const dict = this.settings.censorDictionaries.find((d) => d.name === this.selectedDictionaryName);
    this.dictionaryText = dict ? dict.content : "";
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian20.Setting(contentEl).setName("Censor and alias").setHeading();
    if (this.fileOrFolder) {
      const type = this.fileOrFolder instanceof import_obsidian20.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path} (${type})` });
    } else {
      new import_obsidian20.Setting(contentEl).setName("Target folder").setDesc("Select the folder to process").addText((text) => text.setPlaceholder("Example: Folder/Subfolder").onChange((value) => {
        const folder = this.app.vault.getAbstractFileByPath(value);
        if (folder instanceof import_obsidian20.TFolder) {
          this.targetFolder = folder;
        } else {
          this.targetFolder = null;
        }
      }));
    }
    new import_obsidian20.Setting(contentEl).setName("Direction").setDesc("Forward (Censor) or Reverse (Uncensor)").addDropdown((drop) => drop.addOption("forward", "Forward (Censor)").addOption("reverse", "Reverse (Uncensor)").setValue(this.direction).onChange((value) => {
      this.direction = value;
      this.display();
    }));
    if (this.direction === "forward") {
      new import_obsidian20.Setting(contentEl).setName("Use masking").setDesc("Replace with \u2588 instead of alias").addToggle((toggle) => toggle.setValue(this.useMasking).onChange((value) => {
        this.useMasking = value;
        this.display();
      }));
      if (this.useMasking) {
        new import_obsidian20.Setting(contentEl).setName("Sentence level masking").setDesc("Block entire sentence containing censored word").addToggle((toggle) => toggle.setValue(this.sentenceLevel).onChange((value) => this.sentenceLevel = value));
      }
    }
    if (!this.fileOrFolder || this.fileOrFolder instanceof import_obsidian20.TFolder) {
      new import_obsidian20.Setting(contentEl).setName("Recursive").setDesc("Process subfolders").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
    }
    new import_obsidian20.Setting(contentEl).setName("Dictionary").setDesc("Select dictionary to use").addDropdown((drop) => {
      this.settings.censorDictionaries.forEach((d) => drop.addOption(d.name, d.name));
      drop.setValue(this.selectedDictionaryName).onChange((value) => {
        this.selectedDictionaryName = value;
        this.updateDictionaryText();
        this.display();
      });
    });
    new import_obsidian20.Setting(contentEl).setName("Dictionary content").setDesc("Edit the censored words and aliases (Changes here are temporary unless saved in settings)").addTextArea((text) => text.setValue(this.dictionaryText).setPlaceholder("Variant1, Variant2 = Alias").onChange((value) => this.dictionaryText = value).inputEl.rows = 10);
    new import_obsidian20.Setting(contentEl).addButton((btn) => btn.setButtonText("Process").setCta().onClick(() => this.process()));
  }
  async process() {
    const target = this.fileOrFolder || this.targetFolder;
    if (!target) {
      new import_obsidian20.Notice("Invalid target selected");
      return;
    }
    const dictionary = this.parseDictionary(this.dictionaryText);
    let files = [];
    if (target instanceof import_obsidian20.TFile) {
      files.push(target);
    } else if (target instanceof import_obsidian20.TFolder) {
      files = this.getFiles(target, this.recursive);
    }
    if (files.length === 0) {
      new import_obsidian20.Notice("No markdown files found to process.");
      return;
    }
    new import_obsidian20.Notice(`Processing ${files.length} files...`);
    this.close();
    let processedCount = 0;
    for (const file of files) {
      const suffix = this.direction === "reverse" ? "_reversed" : this.settings.censorSuffix;
      await this.service.processFile(
        file,
        dictionary,
        this.direction,
        this.useMasking,
        this.sentenceLevel,
        this.settings.censorOutputMode,
        suffix,
        this.settings.censorReplacementChar
      );
      processedCount++;
    }
    new import_obsidian20.Notice(`Processed ${processedCount} files.`);
  }
  getFiles(folder, recursive) {
    let files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian20.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian20.TFolder && recursive) {
        files = files.concat(this.getFiles(child, recursive));
      }
    }
    return files;
  }
  parseDictionary(text) {
    const dictionary = [];
    const lines = text.split("\n");
    for (const line of lines) {
      if (line.trim().startsWith("#") || !line.trim())
        continue;
      const parts = line.split("=");
      if (parts.length === 2) {
        const variants = parts[0].split(",").map((v) => v.trim()).filter((v) => v);
        const alias = parts[1].trim();
        if (variants.length > 0 && alias) {
          dictionary.push({ variants, alias });
        }
      }
    }
    return dictionary;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/merge-modal.ts
var import_obsidian23 = require("obsidian");

// src/ui/chrono-merge-modal.ts
var import_obsidian22 = require("obsidian");

// src/modules/chrono-merge.ts
var import_obsidian21 = require("obsidian");
var ChronoMergeService = class {
  constructor(app) {
    this.app = app;
  }
  async scanFolder(folder, minutesThreshold, recursive, useCreationTime) {
    const files = this.getFiles(folder, recursive);
    const filesWithTime = [];
    for (const file of files) {
      let time = null;
      if (useCreationTime) {
        time = file.stat.ctime;
      } else {
        time = this.parseTimestamp(file.name);
      }
      if (time) {
        filesWithTime.push({ file, time });
      }
    }
    filesWithTime.sort((a, b) => a.time - b.time);
    const groups = [];
    if (filesWithTime.length === 0)
      return groups;
    let currentGroup = [filesWithTime[0].file];
    let currentTime = filesWithTime[0].time;
    for (let i = 1; i < filesWithTime.length; i++) {
      const { file, time } = filesWithTime[i];
      const diffMinutes = (time - currentTime) / (1e3 * 60);
      if (diffMinutes <= minutesThreshold) {
        currentGroup.push(file);
      } else {
        if (currentGroup.length > 1) {
          groups.push(currentGroup);
        }
        currentGroup = [file];
        currentTime = time;
      }
    }
    if (currentGroup.length > 1) {
      groups.push(currentGroup);
    }
    return groups;
  }
  async getMergedContent(group, useCreationTime) {
    const sortedGroup = group.sort((a, b) => {
      const timeA = useCreationTime ? a.stat.ctime : this.parseTimestamp(a.name) || 0;
      const timeB = useCreationTime ? b.stat.ctime : this.parseTimestamp(b.name) || 0;
      return timeA - timeB;
    });
    let mergedContent = "";
    for (let i = 0; i < sortedGroup.length; i++) {
      const file = sortedGroup[i];
      let content = await this.app.vault.read(file);
      if (i > 0) {
        const yamlMatch = content.match(/^---\n[\s\S]*?\n---\n/);
        if (yamlMatch) {
          content = content.replace(yamlMatch[0], "");
        }
      }
      mergedContent += content.trim() + "\n\n";
    }
    return mergedContent;
  }
  async mergeGroup(group, outputName, useCreationTime, contentOverride) {
    if (group.length === 0)
      return;
    const sortedGroup = group.sort((a, b) => {
      const timeA = useCreationTime ? a.stat.ctime : this.parseTimestamp(a.name) || 0;
      const timeB = useCreationTime ? b.stat.ctime : this.parseTimestamp(b.name) || 0;
      return timeA - timeB;
    });
    const earliestFile = sortedGroup[0];
    const parent = earliestFile.parent;
    if (!parent)
      return;
    let mergedContent = contentOverride;
    if (mergedContent === void 0) {
      mergedContent = await this.getMergedContent(group, useCreationTime);
    }
    const newFileName = outputName.endsWith(".md") ? outputName : `${outputName}.md`;
    const newFilePath = (0, import_obsidian21.normalizePath)(`${parent.path}/${newFileName}`);
    const baseFile = group.find((f) => f.path === newFilePath);
    for (const file of sortedGroup) {
      if (file !== baseFile) {
        await this.app.fileManager.trashFile(file);
      }
    }
    if (baseFile) {
      await this.app.vault.modify(baseFile, mergedContent);
    } else {
      const existingFile = this.app.vault.getAbstractFileByPath(newFilePath);
      if (existingFile) {
        let counter2 = 1;
        let safeName = newFileName;
        while (this.app.vault.getAbstractFileByPath((0, import_obsidian21.normalizePath)(`${parent.path}/${safeName}`))) {
          safeName = `${outputName.replace(".md", "")}_${counter2}.md`;
          counter2++;
        }
        const safePath = (0, import_obsidian21.normalizePath)(`${parent.path}/${safeName}`);
        await this.app.vault.create(safePath, mergedContent);
      } else {
        await this.app.vault.create(newFilePath, mergedContent);
      }
    }
    const folderFiles = parent.children;
    const usedNames = /* @__PURE__ */ new Set();
    usedNames.add(newFileName);
    let counter = 1;
    for (const file of sortedGroup) {
      const baseName = file.basename;
      for (const child of folderFiles) {
        if (child instanceof import_obsidian21.TFile && child.basename === baseName && child.extension !== "md") {
          let newAssocName = "";
          if (counter === 1) {
            newAssocName = `${outputName.replace(".md", "")}.${child.extension}`;
          } else {
            newAssocName = `${outputName.replace(".md", "")}_${counter}.${child.extension}`;
          }
          let tempCounter = counter;
          while (usedNames.has(newAssocName)) {
            tempCounter++;
            newAssocName = `${outputName.replace(".md", "")}_${tempCounter}.${child.extension}`;
          }
          const newAssocPath = (0, import_obsidian21.normalizePath)(`${parent.path}/${newAssocName}`);
          if (!this.app.vault.getAbstractFileByPath(newAssocPath)) {
            await this.app.fileManager.renameFile(child, newAssocPath);
            usedNames.add(newAssocName);
          }
          counter++;
        }
      }
    }
  }
  getFiles(folder, recursive) {
    let files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian21.TFile && child.extension === "md") {
        files.push(child);
      } else if (recursive && child instanceof import_obsidian21.TFolder) {
        files = files.concat(this.getFiles(child, recursive));
      }
    }
    return files;
  }
  parseTimestamp(filename) {
    const match = filename.match(/(\d{4}-\d{2}-\d{2}_\d{6})/);
    if (match) {
      const dateStr = match[1];
      const formatted = dateStr.replace("_", "T").replace(/(\d{2})(\d{2})(\d{2})$/, "$1:$2:$3");
      return new Date(formatted).getTime();
    }
    return null;
  }
};

// src/ui/chrono-merge-modal.ts
var ChronoMergeModal = class extends import_obsidian22.Modal {
  constructor(app, settings, folder) {
    super(app);
    this.targetFolder = null;
    this.recursive = false;
    this.threshold = 5;
    this.groups = [];
    this.useCreationTime = false;
    this.service = new ChronoMergeService(app);
    this.targetFolder = folder || null;
    this.folder = folder;
    this.threshold = settings.chronoMergeTimeThreshold;
    this.useCreationTime = settings.chronoMergeUseCreationTime;
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian22.Setting(contentEl).setName("Chrono merge").setHeading();
    if (!this.groups.length) {
      if (this.folder) {
        contentEl.createEl("p", { text: `Folder: ${this.folder.path}` });
      } else {
        new import_obsidian22.Setting(contentEl).setName("Folder").setDesc("Select folder to scan").addText((text) => text.setPlaceholder("Example: Folder/Subfolder").onChange((value) => {
          const f = this.app.vault.getAbstractFileByPath(value);
          if (f instanceof import_obsidian22.TFolder)
            this.targetFolder = f;
          else
            this.targetFolder = null;
        }));
      }
      new import_obsidian22.Setting(contentEl).setName("Recursive").setDesc("Scan subfolders").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
      new import_obsidian22.Setting(contentEl).setName("Time threshold (minutes)").setDesc("Max time difference between files to group them").addText((text) => text.setValue(this.threshold.toString()).onChange((value) => {
        const num = parseInt(value);
        if (!isNaN(num))
          this.threshold = num;
      }));
      new import_obsidian22.Setting(contentEl).addButton((btn) => btn.setButtonText("Scan").setCta().onClick(() => this.scan()));
    } else {
      new import_obsidian22.Setting(contentEl).setName(`Found ${this.groups.length} groups`).setHeading();
      this.groups.forEach((group, index) => {
        const groupEl = contentEl.createDiv({ cls: "chrono-group" });
        groupEl.addClass("coherence-chrono-group");
        new import_obsidian22.Setting(groupEl).setName(`Group ${index + 1} (${group.length} files)`).setHeading();
        const fileList = groupEl.createEl("ul");
        group.forEach((file) => {
          fileList.createEl("li", { text: file.name });
        });
        const earliestFile = group[0];
        let outputName = earliestFile.basename;
        let mergedContent = "";
        const nameContainer = groupEl.createDiv();
        nameContainer.style.marginBottom = "10px";
        nameContainer.createEl("div", { text: "Output Filename", cls: "setting-item-name" });
        const nameInput = nameContainer.createEl("input", { type: "text" });
        nameInput.addClass("coherence-input-full");
        nameInput.value = outputName;
        nameInput.onchange = (e) => outputName = e.target.value;
        const contentContainer = groupEl.createDiv();
        contentContainer.style.marginBottom = "10px";
        contentContainer.createEl("div", { text: "Merged Content", cls: "setting-item-name" });
        const contentArea = contentContainer.createEl("textarea");
        contentArea.addClass("coherence-textarea-full");
        contentArea.rows = 10;
        contentArea.value = "Loading content...";
        contentArea.onchange = (e) => mergedContent = e.target.value;
        void this.service.getMergedContent(group, this.useCreationTime).then((content) => {
          mergedContent = content;
          contentArea.value = content;
        });
        const btnContainer = groupEl.createDiv({ cls: "coherence-btn-container-right" });
        const skipBtn = btnContainer.createEl("button", { text: "Skip Group" });
        skipBtn.addClass("coherence-btn-margin-right");
        skipBtn.onclick = () => {
          groupEl.remove();
          const idx = this.groups.indexOf(group);
          if (idx > -1)
            this.groups.splice(idx, 1);
          if (this.groups.length === 0) {
            this.display();
          }
        };
        const btn = btnContainer.createEl("button", { text: "Merge Group" });
        btn.addClass("mod-cta");
        btn.onclick = async () => {
          await this.service.mergeGroup(group, outputName, this.useCreationTime, mergedContent);
          new import_obsidian22.Notice(`Merged group into ${outputName}.md`);
          groupEl.remove();
          const idx = this.groups.indexOf(group);
          if (idx > -1)
            this.groups.splice(idx, 1);
          if (this.groups.length === 0) {
            this.display();
          }
        };
      });
      new import_obsidian22.Setting(contentEl).addButton((btn) => btn.setButtonText("Back to Scan").onClick(() => {
        this.groups = [];
        this.display();
      }));
    }
  }
  async scan() {
    const folder = this.targetFolder || (this.folder ? this.folder : this.app.vault.getRoot());
    if (!folder) {
      new import_obsidian22.Notice("Invalid folder");
      return;
    }
    new import_obsidian22.Notice("Scanning...");
    this.groups = await this.service.scanFolder(folder, this.threshold, this.recursive, this.useCreationTime);
    if (this.groups.length === 0) {
      new import_obsidian22.Notice("No groups found matching the criteria.");
    } else {
      this.display();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.onCloseCallback) {
      this.onCloseCallback();
    }
  }
};

// src/ui/merge-modal.ts
var MergeModal = class extends import_obsidian23.Modal {
  constructor(app, settings, fileOrFolder) {
    super(app);
    this.settings = settings;
    this.fileOrFolder = fileOrFolder;
    this.mode = "chrono";
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian23.Setting(contentEl).setName("Merge tools").setHeading();
    if (this.fileOrFolder) {
      const type = this.fileOrFolder instanceof import_obsidian23.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path} (${type})` });
    }
    new import_obsidian23.Setting(contentEl).setName("Select merge tool").setDesc("Choose the merge strategy to use.").addDropdown((drop) => drop.addOption("chrono", "Chrono Merge (Time-based)").addOption("concat", "Combine (Append files)").addOption("dedup", "Find Duplicates").setValue(this.mode).onChange((value) => {
      this.mode = value;
    }));
    new import_obsidian23.Setting(contentEl).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
      var _a;
      this.close();
      if (this.mode === "chrono") {
        const folder = this.fileOrFolder instanceof import_obsidian23.TFolder ? this.fileOrFolder : (_a = this.fileOrFolder) == null ? void 0 : _a.parent;
        new ChronoMergeModal(this.app, this.settings, folder).open();
      } else if (this.mode === "concat") {
        new ConcatonizerModal(this.app, this.settings, this.fileOrFolder).open();
      } else if (this.mode === "dedup") {
        new DeduplicationModal(this.app, this.fileOrFolder).open();
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/categorize-hub-modal.ts
var import_obsidian26 = require("obsidian");

// src/ui/categorizer-modal.ts
var import_obsidian25 = require("obsidian");

// src/modules/categorizer.ts
var import_obsidian24 = require("obsidian");
var CategorizerService = class {
  constructor(app, ollama) {
    this.app = app;
    this.ollama = ollama;
  }
  async categorizeFile(file, options) {
    try {
      const content = await this.app.vault.read(file);
      const assignedCategories = await this.getCategoriesFromAI(content, options.model, options.categories, options.maxCategories);
      if (assignedCategories.length > 0) {
        await this.processFile(file, assignedCategories, options);
        return assignedCategories;
      }
      return [];
    } catch (e) {
      console.error(`Failed to categorize file ${file.path}`, e);
      return [];
    }
  }
  async processFile(file, assignedCategories, options) {
    if (options.applyAsTag) {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        let currentTags = frontmatter["tags"];
        if (!currentTags) {
          currentTags = [];
        } else if (!Array.isArray(currentTags)) {
          if (typeof currentTags === "string") {
            currentTags = currentTags.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
          } else {
            currentTags = [String(currentTags)];
          }
        }
        assignedCategories.forEach((c) => {
          let cleanCategory = c.startsWith("#") ? c.substring(1) : c;
          cleanCategory = cleanCategory.replace(/\s+/g, "_");
          const variantsToRemove = [
            c,
            `#${c}`,
            c.replace(/^#/, ""),
            cleanCategory.replace(/_/g, " ")
            // version with spaces
          ];
          variantsToRemove.forEach((variant) => {
            const idx = currentTags.indexOf(variant);
            if (idx > -1)
              currentTags.splice(idx, 1);
          });
          if (!currentTags.includes(cleanCategory)) {
            currentTags.push(cleanCategory);
          }
        });
        frontmatter["tags"] = currentTags;
      });
    }
    if (options.applyAsBacklink) {
      const backlinks = assignedCategories.map((c) => `[[${c}]]`).join(" ");
      const content = await this.app.vault.read(file);
      await this.app.vault.modify(file, content + `

${backlinks}`);
    }
    if (options.moveToFolder && assignedCategories.length > 0) {
      const parentPath = file.parent ? file.parent.path : "";
      const firstCategory = assignedCategories[0];
      const firstDestFolder = (0, import_obsidian24.normalizePath)(`${parentPath}/${this.sanitizeFileName(firstCategory)}`);
      const firstDestPath = (0, import_obsidian24.normalizePath)(`${firstDestFolder}/${file.name}`);
      if (!await this.app.vault.adapter.exists(firstDestFolder)) {
        await this.app.vault.createFolder(firstDestFolder);
      }
      if (await this.app.vault.adapter.exists(firstDestPath)) {
        new import_obsidian24.Notice(`File ${file.name} already exists in ${firstCategory}. Skipping move.`);
      } else {
        await this.app.fileManager.renameFile(file, firstDestPath);
      }
      for (let i = 1; i < assignedCategories.length; i++) {
        const category = assignedCategories[i];
        const destFolder = (0, import_obsidian24.normalizePath)(`${parentPath}/${this.sanitizeFileName(category)}`);
        const destPath = (0, import_obsidian24.normalizePath)(`${destFolder}/${file.name}`);
        if (!await this.app.vault.adapter.exists(destFolder)) {
          await this.app.vault.createFolder(destFolder);
        }
        if (!await this.app.vault.adapter.exists(destPath)) {
          await this.app.vault.copy(file, destPath);
        }
      }
    }
  }
  async processFolder(folderPath, options, recursive, onProgress) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let categorized = 0;
    let errors = 0;
    const total = files.length;
    for (let i = 0; i < total; i++) {
      const file = files[i];
      if (onProgress) {
        onProgress(i + 1, total, file.name);
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
      processed++;
      try {
        const cats = await this.categorizeFile(file, options);
        if (cats.length > 0) {
          categorized++;
        }
      } catch (e) {
        console.error(`Error processing ${file.path}`, e);
        errors++;
      }
    }
    return { processed, categorized, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder && "children" in folder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian24.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  async getCategoriesFromAI(text, model, categories, maxCategories) {
    const categoriesList = categories.join("\n- ");
    const systemPrompt = `You are a strict classifier.
Select up to ${maxCategories} categories from the provided list that best fit the note.
Return JSON only, matching the given schema.

Categories:
- ${categoriesList}

If multiple categories are plausible, pick the most relevant ones, up to the limit of ${maxCategories}.`;
    const schema = {
      "type": "object",
      "properties": {
        "categories": {
          "type": "array",
          "items": { "type": "string", "enum": categories },
          "maxItems": maxCategories
        }
      },
      "required": ["categories"],
      "additionalProperties": false
    };
    try {
      const response = await this.ollama.chat(model, [
        { role: "system", content: systemPrompt },
        { role: "user", content: text }
      ], schema, { temperature: 0 });
      const data = JSON.parse(response);
      let result = data.categories || [];
      if (result.length > maxCategories) {
        result = result.slice(0, maxCategories);
      }
      return result;
    } catch (e) {
      console.error("AI Classification failed", e);
      return [];
    }
  }
  sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "_").trim();
  }
};

// src/ui/categorizer-modal.ts
var CategorizerModal = class extends import_obsidian25.Modal {
  constructor(app, settings, target) {
    super(app);
    this.recursive = false;
    this.ollamaModels = [];
    this.settings = settings;
    const ollama = new OllamaService(settings.ollamaUrl);
    this.service = new CategorizerService(app, ollama);
    this.target = target;
    this.model = settings.categorizerModel || "llama3";
    this.selectedDictionary = settings.categorizerActiveDictionary || "General";
    this.maxCategories = settings.categorizerMaxCategories || 1;
    this.applyAsTag = settings.categorizerApplyAsTag;
    this.applyAsBacklink = settings.categorizerApplyAsBacklink;
    this.moveToFolder = settings.categorizerMoveToFolder;
  }
  async onOpen() {
    await this.fetchModels();
    this.display();
  }
  async fetchModels() {
    try {
      const ollama = new OllamaService(this.settings.ollamaUrl);
      this.ollamaModels = await ollama.listModels();
      if (this.ollamaModels.length === 0) {
        this.ollamaModels = ["llama3", "mistral", "gemma"];
      }
    } catch (e) {
      console.error("Failed to fetch models", e);
      this.ollamaModels = ["llama3", "mistral", "gemma"];
    }
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Categorizer" });
    if (this.target) {
      const type = this.target instanceof import_obsidian25.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.target.name} (${type})` });
    } else {
      contentEl.createEl("p", { text: "No target selected.", cls: "error-text" });
      return;
    }
    new import_obsidian25.Setting(contentEl).setName("Model").addDropdown((drop) => {
      this.ollamaModels.forEach((m) => drop.addOption(m, m));
      if (!this.ollamaModels.includes(this.model)) {
        drop.addOption(this.model, this.model);
      }
      drop.setValue(this.model).onChange((v) => this.model = v);
    });
    new import_obsidian25.Setting(contentEl).setName("Dictionary").setDesc("Select the category dictionary to use").addDropdown((drop) => {
      if (this.settings.categorizerDictionaries) {
        this.settings.categorizerDictionaries.forEach((d) => drop.addOption(d.name, d.name));
      }
      drop.setValue(this.selectedDictionary).onChange((v) => this.selectedDictionary = v);
    });
    new import_obsidian25.Setting(contentEl).setName("Max Categories").setDesc("Maximum number of categories to apply per file").addText((text) => text.setValue(String(this.maxCategories)).onChange((v) => {
      const num = parseInt(v);
      if (!isNaN(num) && num > 0)
        this.maxCategories = num;
    }));
    contentEl.createEl("h3", { text: "Application Options" });
    new import_obsidian25.Setting(contentEl).setName("Apply as Tag").addToggle((t) => t.setValue(this.applyAsTag).onChange((v) => this.applyAsTag = v));
    new import_obsidian25.Setting(contentEl).setName("Apply as Backlink").addToggle((t) => t.setValue(this.applyAsBacklink).onChange((v) => this.applyAsBacklink = v));
    new import_obsidian25.Setting(contentEl).setName("Move to Folder").setDesc("Move/Copy file to category folder(s)").addToggle((t) => t.setValue(this.moveToFolder).onChange((v) => this.moveToFolder = v));
    if (!(this.target instanceof import_obsidian25.TFile)) {
      new import_obsidian25.Setting(contentEl).setName("Recursive").setDesc("Process subfolders").addToggle((t) => t.setValue(this.recursive).onChange((v) => this.recursive = v));
    }
    new import_obsidian25.Setting(contentEl).addButton((btn) => btn.setButtonText("Start Categorizing").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      const progressContainer = contentEl.createDiv();
      progressContainer.style.marginTop = "20px";
      const progressBarBg = progressContainer.createDiv();
      progressBarBg.style.width = "100%";
      progressBarBg.style.height = "10px";
      progressBarBg.style.backgroundColor = "var(--background-modifier-border)";
      progressBarBg.style.borderRadius = "5px";
      const progressBar = progressBarBg.createDiv();
      progressBar.style.width = "0%";
      progressBar.style.height = "100%";
      progressBar.style.backgroundColor = "var(--interactive-accent)";
      progressBar.style.borderRadius = "5px";
      progressBar.style.transition = "width 0.1s";
      const progressText = progressContainer.createDiv();
      progressText.style.marginTop = "5px";
      progressText.style.fontSize = "0.8em";
      progressText.style.color = "var(--text-muted)";
      progressText.setText("Starting...");
      const onProgress = (processed, total, currentFile) => {
        const percent = Math.floor(processed / total * 100);
        progressBar.style.width = `${percent}%`;
        progressText.setText(`Processing ${processed}/${total}: ${currentFile}`);
      };
      const dict = this.settings.categorizerDictionaries.find((d) => d.name === this.selectedDictionary);
      const categories = dict ? dict.content.split("\n").map((c) => c.split(";")[0].trim()).filter((c) => c.length > 0) : [];
      if (categories.length === 0) {
        new import_obsidian25.Notice("Selected dictionary is empty!");
        btn.setButtonText("Start Categorizing").setDisabled(false);
        return;
      }
      const options = {
        model: this.model,
        categories,
        maxCategories: this.maxCategories,
        applyAsTag: this.applyAsTag,
        applyAsBacklink: this.applyAsBacklink,
        moveToFolder: this.moveToFolder
      };
      try {
        if (this.target instanceof import_obsidian25.TFile) {
          const cats = await this.service.categorizeFile(this.target, options);
          if (cats.length > 0) {
            new import_obsidian25.Notice(`Categorized as: ${cats.join(", ")}`);
          } else {
            new import_obsidian25.Notice("No categories assigned.");
          }
        } else {
          const res = await this.service.processFolder(this.target.path, options, this.recursive, onProgress);
          new import_obsidian25.Notice(`Processed: ${res.processed}, Categorized: ${res.categorized}, Errors: ${res.errors}`);
        }
        this.close();
      } catch (e) {
        new import_obsidian25.Notice("Error during categorization");
        console.error(e);
        btn.setButtonText("Start Categorizing").setDisabled(false);
        progressText.setText("Error occurred.");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/categorize-hub-modal.ts
var CategorizeHubModal = class extends import_obsidian26.Modal {
  constructor(app, settings, saveSettings, fileOrFolder) {
    super(app);
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.fileOrFolder = fileOrFolder;
    this.mode = "categorize";
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian26.Setting(contentEl).setName("Categorize tools").setHeading();
    if (this.fileOrFolder) {
      const type = this.fileOrFolder instanceof import_obsidian26.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path} (${type})` });
    }
    new import_obsidian26.Setting(contentEl).setName("Select tool").setDesc("Choose the categorization or rating tool to use.").addDropdown((drop) => drop.addOption("categorize", "Categorize (Assign Categories)").addOption("rate", "Auto Rate (Assign Quality Score)").setValue(this.mode).onChange((value) => {
      this.mode = value;
    }));
    new import_obsidian26.Setting(contentEl).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
      this.close();
      if (this.mode === "categorize") {
        new CategorizerModal(this.app, this.settings, this.fileOrFolder).open();
      } else if (this.mode === "rate") {
        new RatingModal(this.app, this.settings, this.saveSettings, this.fileOrFolder).open();
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/distill-modal.ts
var import_obsidian29 = require("obsidian");

// src/ui/generalizer-modal.ts
var import_obsidian28 = require("obsidian");

// src/modules/generalizer.ts
var import_obsidian27 = require("obsidian");
var GeneralizerService = class {
  constructor(app, settings) {
    this.app = app;
    this.ollama = new OllamaService(settings.ollamaUrl);
  }
  async processFile(file, model, promptTemplate, outputMode, suffix, systemPrompt, maxTokens, repeatPenalty, multiStage, intermediatePrompt) {
    const content = await this.app.vault.read(file);
    const { yaml, body } = this.parseYaml(content);
    if (!body.trim()) {
      return;
    }
    let inputBody = body;
    try {
      if (multiStage) {
        let summaryPrompt = "";
        if (intermediatePrompt.includes("{text}")) {
          summaryPrompt = intermediatePrompt.replace("{text}", body);
        } else {
          summaryPrompt = `${intermediatePrompt}

${body}`;
        }
        const summary = await this.ollama.generate(model, summaryPrompt, {
          system: systemPrompt,
          // Use the same system prompt to enforce "no preamble"
          num_predict: maxTokens,
          repeat_penalty: repeatPenalty
        });
        inputBody = summary.replace(/<\/end_of_turn>/g, "").trim();
      }
      let prompt = "";
      if (promptTemplate.includes("{text}")) {
        prompt = promptTemplate.replace("{text}", inputBody);
      } else {
        prompt = `${promptTemplate}

${inputBody}`;
      }
      let generalizedText = await this.ollama.generate(model, prompt, {
        system: systemPrompt,
        num_predict: maxTokens,
        repeat_penalty: repeatPenalty
      });
      generalizedText = generalizedText.replace(/<\/end_of_turn>/g, "").trim();
      const newContent = yaml ? `${yaml}
${generalizedText}` : generalizedText;
      await this.saveOutput(file, newContent, outputMode, suffix);
    } catch (error) {
      console.error(`Error generalizing file ${file.path}:`, error);
      throw error;
    }
  }
  async processFolder(folderPath, model, promptTemplate, outputMode, suffix, recursive, systemPrompt, maxTokens, repeatPenalty, multiStage, intermediatePrompt) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let errors = 0;
    for (const file of files) {
      try {
        await this.processFile(file, model, promptTemplate, outputMode, suffix, systemPrompt, maxTokens, repeatPenalty, multiStage, intermediatePrompt);
        processed++;
      } catch (e) {
        errors++;
      }
    }
    return { processed, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian27.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian27.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  parseYaml(content) {
    const match = content.match(/^(---\n[\s\S]*?\n---)\n([\s\S]*)$/);
    if (match) {
      return { yaml: match[1], body: match[2] };
    }
    return { yaml: "", body: content };
  }
  async saveOutput(file, content, outputMode, suffix) {
    let targetPath;
    if (outputMode === "folder") {
      const parentPath = file.parent ? file.parent.path : "/";
      const parentDir = parentPath === "/" ? "" : parentPath;
      const outputDir = (0, import_obsidian27.normalizePath)(`${parentDir}/Generalized`);
      if (!await this.app.vault.adapter.exists(outputDir)) {
        await this.app.vault.createFolder(outputDir);
      }
      targetPath = (0, import_obsidian27.normalizePath)(`${outputDir}/${file.basename}${suffix}.${file.extension}`);
    } else {
      const parentPath = file.parent ? file.parent.path : "/";
      const parentDir = parentPath === "/" ? "" : parentPath;
      targetPath = (0, import_obsidian27.normalizePath)(`${parentDir}/${file.basename}${suffix}.${file.extension}`);
    }
    if (await this.app.vault.adapter.exists(targetPath)) {
      const existing = this.app.vault.getAbstractFileByPath(targetPath);
      if (existing instanceof import_obsidian27.TFile) {
        await this.app.vault.modify(existing, content);
      }
    } else {
      await this.app.vault.create(targetPath, content);
    }
  }
};

// src/ui/generalizer-modal.ts
var GeneralizerModal = class extends import_obsidian28.Modal {
  constructor(app, settings, fileOrFolder) {
    super(app);
    this.settings = settings;
    this.fileOrFolder = fileOrFolder;
    this.targetFolder = null;
    this.recursive = false;
    this.outputMode = "folder";
    this.suffix = "_generalized";
    this.model = "llama3";
    this.models = [];
    this.mode = "generalize";
    this.multiStage = false;
    this.service = new GeneralizerService(app, settings);
    this.ollamaService = new OllamaService(settings.ollamaUrl);
    this.recursive = settings.generalizerRecursive || false;
    this.outputMode = settings.generalizerOutputMode || "folder";
    this.suffix = settings.generalizerSuffix || "_generalized";
    this.model = settings.generalizerModel || "llama3";
    this.multiStage = settings.generalizerMultiStage || false;
  }
  async onOpen() {
    this.models = await this.ollamaService.getModels();
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian28.Setting(contentEl).setName("Generalizer (Wisdom extractor)").setHeading();
    if (this.fileOrFolder) {
      const type = this.fileOrFolder instanceof import_obsidian28.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path} (${type})` });
    } else {
      new import_obsidian28.Setting(contentEl).setName("Target folder").setDesc("Select the folder to process").addText((text) => text.setPlaceholder("Example: Folder/Subfolder").onChange((value) => {
        const folder = this.app.vault.getAbstractFileByPath(value);
        if (folder instanceof import_obsidian28.TFolder) {
          this.targetFolder = folder;
        } else {
          this.targetFolder = null;
        }
      }));
    }
    new import_obsidian28.Setting(contentEl).setName("Mode").setDesc("Select the generalization strategy").addDropdown((drop) => drop.addOption("generalize", "Standard Generalization").addOption("wisdom", "Wisdom Extractor (Self-Help)").setValue(this.mode).onChange((value) => {
      this.mode = value;
      if (this.mode === "wisdom") {
        this.suffix = "_wisdom";
      } else {
        this.suffix = this.settings.generalizerSuffix || "_generalized";
      }
      this.display();
    }));
    new import_obsidian28.Setting(contentEl).setName("Model").setDesc("Select Ollama model").addDropdown((drop) => {
      this.models.forEach((m) => drop.addOption(m, m));
      drop.setValue(this.model).onChange((value) => this.model = value);
    });
    new import_obsidian28.Setting(contentEl).setName("Multi-stage processing").setDesc("Summarize text before generalizing (improves compliance for large files)").addToggle((toggle) => toggle.setValue(this.multiStage).onChange((value) => this.multiStage = value));
    if (!this.fileOrFolder || this.fileOrFolder instanceof import_obsidian28.TFolder) {
      new import_obsidian28.Setting(contentEl).setName("Recursive").setDesc("Process subfolders").addToggle((toggle) => toggle.setValue(this.recursive).onChange((value) => this.recursive = value));
    }
    new import_obsidian28.Setting(contentEl).setName("Output mode").setDesc("Where to save generalized files").addDropdown((drop) => drop.addOption("folder", 'New "Generalized" Folder').addOption("same-folder", "Same Folder (Next to original)").setValue(this.outputMode).onChange((value) => this.outputMode = value));
    new import_obsidian28.Setting(contentEl).setName("Filename suffix").setDesc("Suffix to append to generalized files").addText((text) => text.setValue(this.suffix).onChange((value) => this.suffix = value));
    new import_obsidian28.Setting(contentEl).addButton((btn) => btn.setButtonText("Generalize").setCta().onClick(() => this.process()));
  }
  async process() {
    const target = this.fileOrFolder || this.targetFolder;
    if (!target) {
      new import_obsidian28.Notice("Invalid target selected");
      return;
    }
    this.close();
    new import_obsidian28.Notice("Generalizing...");
    const prompt = this.mode === "wisdom" ? this.settings.generalizerWisdomPrompt : this.settings.generalizerPrompt;
    if (target instanceof import_obsidian28.TFile) {
      try {
        await this.service.processFile(
          target,
          this.model,
          prompt,
          this.outputMode,
          this.suffix,
          this.settings.generalizerSystemPrompt,
          this.settings.generalizerMaxTokens,
          this.settings.generalizerRepeatPenalty,
          this.multiStage,
          this.settings.generalizerIntermediatePrompt
        );
        new import_obsidian28.Notice(`Generalized ${target.basename}`);
      } catch (e) {
        new import_obsidian28.Notice(`Error generalizing ${target.basename}`);
      }
    } else if (target instanceof import_obsidian28.TFolder) {
      const result = await this.service.processFolder(
        target.path,
        this.model,
        prompt,
        this.outputMode,
        this.suffix,
        this.recursive,
        this.settings.generalizerSystemPrompt,
        this.settings.generalizerMaxTokens,
        this.settings.generalizerRepeatPenalty,
        this.multiStage,
        this.settings.generalizerIntermediatePrompt
      );
      new import_obsidian28.Notice(`Processed ${result.processed} files. Errors: ${result.errors}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/distill-modal.ts
var DistillModal = class extends import_obsidian29.Modal {
  constructor(app, settings, fileOrFolder) {
    super(app);
    this.settings = settings;
    this.fileOrFolder = fileOrFolder;
    this.mode = "censor";
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian29.Setting(contentEl).setName("Distill tools").setHeading();
    if (this.fileOrFolder) {
      const type = this.fileOrFolder instanceof import_obsidian29.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.fileOrFolder.path} (${type})` });
    }
    new import_obsidian29.Setting(contentEl).setName("Select tool").setDesc("Choose the distillation tool to use.").addDropdown((drop) => drop.addOption("censor", "Censor / Alias").addOption("generalize", "Generalize (AI)").setValue(this.mode).onChange((value) => {
      this.mode = value;
    }));
    new import_obsidian29.Setting(contentEl).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
      this.close();
      if (this.mode === "censor") {
        new CensorModal(this.app, this.settings, this.fileOrFolder).open();
      } else if (this.mode === "generalize") {
        new GeneralizerModal(this.app, this.settings, this.fileOrFolder).open();
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/wizard-view.ts
var import_obsidian31 = require("obsidian");

// src/modules/yaml-template.ts
var import_obsidian30 = require("obsidian");
var YamlTemplateService = class {
  constructor(app) {
    this.app = app;
  }
  async processFile(file, templateOrder, addDate) {
    try {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        const existingData = { ...frontmatter };
        for (const key in frontmatter)
          delete frontmatter[key];
        if (addDate) {
          const isoDateRegex = /^(\d{4}-\d{2}-\d{2})/;
          const match = file.name.match(isoDateRegex);
          if (match) {
            existingData["date"] = match[1];
          }
        }
        for (const key of templateOrder) {
          const sanitizedKey = this.sanitizeKey(key);
          if (sanitizedKey) {
            frontmatter[sanitizedKey] = existingData[sanitizedKey] !== void 0 ? existingData[sanitizedKey] : "";
            delete existingData[sanitizedKey];
          }
        }
        for (const key in existingData) {
          const sanitizedKey = this.sanitizeKey(key);
          if (sanitizedKey) {
            frontmatter[sanitizedKey] = existingData[key];
          }
        }
      });
    } catch (e) {
      console.error(`Failed to process YAML for ${file.path}`, e);
      throw e;
    }
  }
  async processFolder(folderPath, templateOrder, addDate, recursive) {
    const files = [];
    this.collectFiles(folderPath, files, recursive);
    let processed = 0;
    let errors = 0;
    for (const file of files) {
      try {
        await this.processFile(file, templateOrder, addDate);
        processed++;
      } catch (e) {
        errors++;
      }
    }
    return { processed, errors };
  }
  collectFiles(path, files, recursive) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian30.TFolder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian30.TFile && child.extension === "md") {
          files.push(child);
        } else if (recursive && "children" in child) {
          this.collectFiles(child.path, files, recursive);
        }
      }
    }
  }
  sanitizeKey(key) {
    return key.replace(/[#@&*!|>%{}[\]?,:]/g, "").trim();
  }
};

// src/ui/wizard-view.ts
var VIEW_TYPE_WIZARD = "coherence-wizard-view";
var WizardView = class extends import_obsidian31.ItemView {
  constructor(leaf, app, settings) {
    super(leaf);
    this.step = 0;
    this.availableModels = [];
    this.app = app;
    this.settings = settings;
    this.inboxDir = settings.wizardInboxDir || "Inbox";
    this.chronoDir = settings.wizardChronoDir || "Chrono";
    this.livingDir = settings.wizardLivingDir || "Living";
    this.ollama = new OllamaService(settings.ollamaUrl);
  }
  getViewType() {
    return VIEW_TYPE_WIZARD;
  }
  getDisplayText() {
    return "Coherence Wizard";
  }
  getIcon() {
    return "wand";
  }
  async onOpen() {
    await this.display();
  }
  async display() {
    const container = this.contentEl;
    container.empty();
    new import_obsidian31.Setting(container).setName("Coherence Wizard").setHeading();
    await this.fetchModels();
    await this.ensureFolder(this.inboxDir);
    await this.ensureFolder(this.chronoDir);
    await this.ensureFolder(this.livingDir);
    const inbox = this.app.vault.getAbstractFileByPath(this.inboxDir);
    const chrono = this.app.vault.getAbstractFileByPath(this.chronoDir);
    const living = this.app.vault.getAbstractFileByPath(this.livingDir);
    if (!inbox || !(inbox instanceof import_obsidian31.TFolder)) {
      container.createEl("p", { text: `Error: '${this.inboxDir}' exists but is not a folder.`, cls: "error-text" });
      return;
    }
    if (!chrono || !(chrono instanceof import_obsidian31.TFolder)) {
      container.createEl("p", { text: `Error: '${this.chronoDir}' exists but is not a folder.`, cls: "error-text" });
      return;
    }
    if (!living || !(living instanceof import_obsidian31.TFolder)) {
      container.createEl("p", { text: `Error: '${this.livingDir}' exists but is not a folder.`, cls: "error-text" });
      return;
    }
    this.renderStep(container);
  }
  async fetchModels() {
    try {
      this.availableModels = await this.ollama.listModels();
      if (this.availableModels.length === 0) {
        this.availableModels = ["llama3", "mistral", "gemma"];
      }
    } catch (e) {
      console.error("Failed to fetch models", e);
      this.availableModels = ["llama3", "mistral", "gemma"];
    }
  }
  async ensureFolder(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      try {
        await this.app.vault.createFolder(path);
        new import_obsidian31.Notice(`Created folder: ${path}`);
      } catch (e) {
        console.error(`Failed to create folder ${path}`, e);
        new import_obsidian31.Notice(`Failed to create folder: ${path}`);
      }
    }
  }
  renderStep(container) {
    container.empty();
    new import_obsidian31.Setting(container).setName("Coherence Wizard").setHeading();
    switch (this.step) {
      case 0:
        this.stepDateFix(container);
        break;
      case 1:
        this.stepChronoMerge(container);
        break;
      case 2:
        this.stepAtomize(container);
        break;
      case 3:
        this.stepYaml(container);
        break;
      case 4:
        this.stepSummarize(container);
        break;
      case 5:
        this.stepRate(container);
        break;
      case 6:
        this.stepCategorize(container);
        break;
      case 7:
        this.stepMoveCopy(container);
        break;
      case 8:
        this.stepCombine(container);
        break;
      case 9:
        this.stepWisdom(container);
        break;
      case 10:
        this.stepFinalMerge(container);
        break;
      default:
        container.createEl("p", { text: "Wizard Complete!" });
        new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Close").onClick(() => {
          this.leaf.detach();
        }));
    }
  }
  next() {
    this.step++;
    this.renderStep(this.contentEl);
  }
  // --- Steps ---
  stepDateFix(container) {
    new import_obsidian31.Setting(container).setName("Step 1: Date fix").setHeading();
    container.createEl("p", { text: `Standardize dates in filenames in '${this.inboxDir}'?` });
    let recursive = this.settings.dateFixRecursive;
    let fallback = this.settings.dateFixFallbackToCreationDate;
    let format = this.settings.dateFixDateFormat;
    new import_obsidian31.Setting(container).setName("Recursive").addToggle((t) => t.setValue(recursive).onChange((v) => recursive = v));
    new import_obsidian31.Setting(container).setName("Fallback to Creation Date").addToggle((t) => t.setValue(fallback).onChange((v) => fallback = v));
    new import_obsidian31.Setting(container).setName("Date Format").addText((t) => t.setValue(format).onChange((v) => format = v));
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Run Date Fix").setCta().onClick(async () => {
      const service = new DateFixService(this.app);
      await service.fixDatesInFolder(this.inboxDir, recursive, fallback, format, this.settings.dateFixExceptions);
      new import_obsidian31.Notice("Date Fix Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepChronoMerge(container) {
    new import_obsidian31.Setting(container).setName("Step 2: Chrono merge").setHeading();
    container.createEl("p", { text: `Merge chronological notes in '${this.inboxDir}'?` });
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Open Chrono Merge").setCta().onClick(() => {
      const folder = this.app.vault.getAbstractFileByPath(this.inboxDir);
      const modal = new ChronoMergeModal(this.app, this.settings, folder);
      modal.onCloseCallback = () => {
        this.next();
      };
      modal.open();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepAtomize(container) {
    new import_obsidian31.Setting(container).setName("Step 3: Atomize").setHeading();
    container.createEl("p", { text: `Atomize notes in '${this.inboxDir}'?` });
    let mode = "heading";
    let divider = this.settings.atomizerDivider || "---";
    new import_obsidian31.Setting(container).setName("Mode").addDropdown((d) => d.addOption("heading", "Heading").addOption("date", "Date").addOption("divider", "Divider").setValue(mode).onChange((v) => {
      mode = v;
    }));
    new import_obsidian31.Setting(container).setName("Divider (if mode is Divider)").addText((t) => t.setValue(divider).onChange((v) => divider = v));
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Atomize").setCta().onClick(async () => {
      const service = new AtomizerService(this.app.vault);
      const folder = this.app.vault.getAbstractFileByPath(this.inboxDir);
      new import_obsidian31.Notice("Atomizing...");
      const files = folder.children.filter((c) => c instanceof import_obsidian31.TFile && c.extension === "md");
      for (const child of files) {
        if (mode === "heading")
          await service.atomizeByHeading(child);
        else if (mode === "date")
          await service.atomizeByDate(child);
        else
          await service.atomizeByDivider(child, divider);
      }
      new import_obsidian31.Notice("Atomization Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepYaml(container) {
    new import_obsidian31.Setting(container).setName("Step 4: YAML template").setHeading();
    container.createEl("p", { text: `Apply YAML Template to '${this.inboxDir}'?` });
    let templateStr = this.settings.yamlTemplate;
    let addDate = this.settings.yamlAddDate;
    new import_obsidian31.Setting(container).setName("Add Date").addToggle((t) => t.setValue(addDate).onChange((v) => addDate = v));
    const templateContainer = container.createDiv();
    templateContainer.createEl("p", { text: "Template:" });
    const textArea = templateContainer.createEl("textarea");
    textArea.style.width = "100%";
    textArea.style.height = "100px";
    textArea.value = templateStr;
    textArea.onchange = (e) => templateStr = e.target.value;
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Apply Template").setCta().onClick(async () => {
      const service = new YamlTemplateService(this.app);
      const template = templateStr.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
      await service.processFolder(this.inboxDir, template, addDate, false);
      new import_obsidian31.Notice("YAML Template Applied");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepSummarize(container) {
    new import_obsidian31.Setting(container).setName("Step 5: Summarize").setHeading();
    container.createEl("p", { text: `Summarize notes in '${this.inboxDir}'?` });
    let model = this.settings.summarizerModel;
    let overwrite = this.settings.summarizerOverwrite;
    let genTitle = this.settings.summarizerGenerateTitle;
    new import_obsidian31.Setting(container).setName("Model").addDropdown((d) => {
      this.availableModels.forEach((m) => d.addOption(m, m));
      d.setValue(model).onChange((v) => model = v);
    });
    new import_obsidian31.Setting(container).setName("Overwrite Existing").addToggle((t) => t.setValue(overwrite).onChange((v) => overwrite = v));
    new import_obsidian31.Setting(container).setName("Generate Title").addToggle((t) => t.setValue(genTitle).onChange((v) => genTitle = v));
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Summarize").setCta().onClick(async () => {
      const service = new SummarizerService(this.app, this.ollama);
      new import_obsidian31.Notice("Summarizing... this may take a while.");
      const prompts = [this.settings.summarizerPrompt, this.settings.summarizerPrompt2, this.settings.summarizerPrompt3, this.settings.summarizerPrompt4];
      await service.summarizeFolder(this.inboxDir, model, false, overwrite, prompts, genTitle);
      new import_obsidian31.Notice("Summarization Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepRate(container) {
    new import_obsidian31.Setting(container).setName("Step 6: Auto rate").setHeading();
    container.createEl("p", { text: `Rate notes in '${this.inboxDir}'?` });
    let model = this.settings.ratingModel;
    new import_obsidian31.Setting(container).setName("Model").addDropdown((d) => {
      this.availableModels.forEach((m) => d.addOption(m, m));
      d.setValue(model).onChange((v) => model = v);
    });
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Rate").setCta().onClick(async () => {
      const service = new RatingService(this.app, this.ollama);
      new import_obsidian31.Notice("Rating...");
      const params = this.settings.ratingParams.split(",").map((s) => s.trim());
      await service.rateFolder(this.inboxDir, model, params, false, this.settings.ratingSkipIfRated);
      new import_obsidian31.Notice("Rating Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepCategorize(container) {
    new import_obsidian31.Setting(container).setName("Step 7: Categorize").setHeading();
    container.createEl("p", { text: `Categorize notes in '${this.inboxDir}'?` });
    container.createEl("p", { text: "Note: This will add categories as tags in the YAML frontmatter. The next step will prompt you to move files to their respective Living folders based on these tags.", cls: "setting-item-description" });
    let selectedDict = this.settings.categorizerActiveDictionary;
    let maxCats = this.settings.categorizerMaxCategories;
    let model = this.settings.categorizerModel;
    new import_obsidian31.Setting(container).setName("Model").addDropdown((d) => {
      this.availableModels.forEach((m) => d.addOption(m, m));
      d.setValue(model).onChange((v) => model = v);
    });
    new import_obsidian31.Setting(container).setName("Dictionary").addDropdown((d) => {
      this.settings.categorizerDictionaries.forEach((dict) => d.addOption(dict.name, dict.name));
      d.setValue(selectedDict);
      d.onChange((v) => selectedDict = v);
    });
    new import_obsidian31.Setting(container).setName("Max Categories").addText((t) => t.setValue(maxCats.toString()).onChange((v) => maxCats = parseInt(v) || 1));
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Categorize").setCta().onClick(async () => {
      const service = new CategorizerService(this.app, this.ollama);
      const dict = this.settings.categorizerDictionaries.find((d) => d.name === selectedDict);
      if (!dict)
        return;
      new import_obsidian31.Notice("Categorizing...");
      const options = {
        model,
        categories: dict.content.split("\n").map((line) => {
          const parts = line.split(/[-;]/);
          return parts[0].trim();
        }).filter((s) => s.length > 0),
        maxCategories: maxCats,
        applyAsTag: this.settings.categorizerApplyAsTag,
        applyAsBacklink: this.settings.categorizerApplyAsBacklink,
        moveToFolder: false
      };
      await service.processFolder(this.inboxDir, options, false);
      new import_obsidian31.Notice("Categorization Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepMoveCopy(container) {
    new import_obsidian31.Setting(container).setName("Step 8: Move & copy").setHeading();
    container.createEl("p", { text: `Move categorized files to '${this.livingDir}' and copy to '${this.chronoDir}'?` });
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Execute").setCta().onClick(async () => {
      new import_obsidian31.Notice("Moving and Copying...");
      await this.moveAndCopyLogic();
      new import_obsidian31.Notice("Move & Copy Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  async moveAndCopyLogic() {
    const inbox = this.app.vault.getAbstractFileByPath(this.inboxDir);
    const files = inbox.children.filter((f) => f instanceof import_obsidian31.TFile && f.extension === "md");
    for (const file of files) {
      let category = "";
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        if (fm.tags) {
          if (Array.isArray(fm.tags) && fm.tags.length > 0)
            category = fm.tags[0];
          else if (typeof fm.tags === "string")
            category = fm.tags;
        }
      });
      if (category) {
        category = category.replace(/^#/, "");
        const chronoPath = `${this.chronoDir}/${file.name}`;
        if (!await this.app.vault.adapter.exists(chronoPath)) {
          await this.app.vault.copy(file, chronoPath);
        }
        const categoryDir = `${this.livingDir}/${category}`;
        if (!await this.app.vault.adapter.exists(categoryDir)) {
          await this.app.vault.createFolder(categoryDir);
        }
        const livingPath = `${categoryDir}/${file.name}`;
        if (!await this.app.vault.adapter.exists(livingPath)) {
          await this.app.fileManager.renameFile(file, livingPath);
        }
      }
    }
  }
  stepCombine(container) {
    new import_obsidian31.Setting(container).setName("Step 9: Combine").setHeading();
    container.createEl("p", { text: `Combine files in '${this.livingDir}' subfolders?` });
    let stripYaml = this.settings.concatonizerStripYaml;
    new import_obsidian31.Setting(container).setName("Strip YAML").addToggle((t) => t.setValue(stripYaml).onChange((v) => stripYaml = v));
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Combine").setCta().onClick(async () => {
      const service = new ConcatonizerService(this.app.vault);
      const living = this.app.vault.getAbstractFileByPath(this.livingDir);
      new import_obsidian31.Notice("Combining...");
      for (const child of living.children) {
        if (child instanceof import_obsidian31.TFolder) {
          const outputName = `${child.name}_Combined.md`;
          await service.concatonizeFolder(child.path, outputName, false, stripYaml, true);
        }
      }
      new import_obsidian31.Notice("Combine Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepWisdom(container) {
    new import_obsidian31.Setting(container).setName("Step 10: Extract wisdom").setHeading();
    container.createEl("p", { text: `Extract wisdom from combined files in '${this.livingDir}'?` });
    let model = this.settings.generalizerModel;
    new import_obsidian31.Setting(container).setName("Model").addDropdown((d) => {
      this.availableModels.forEach((m) => d.addOption(m, m));
      d.setValue(model).onChange((v) => model = v);
    });
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Extract").setCta().onClick(async () => {
      const service = new GeneralizerService(this.app, this.settings);
      const living = this.app.vault.getAbstractFileByPath(this.livingDir);
      new import_obsidian31.Notice("Extracting Wisdom...");
      for (const child of living.children) {
        if (child instanceof import_obsidian31.TFolder) {
          const combinedPath = `${child.path}/${child.name}_Combined.md`;
          const file = this.app.vault.getAbstractFileByPath(combinedPath);
          if (file instanceof import_obsidian31.TFile) {
            await service.processFile(
              file,
              model,
              this.settings.generalizerPrompt,
              "same-folder",
              "_Wisdom",
              this.settings.generalizerSystemPrompt,
              this.settings.generalizerMaxTokens,
              this.settings.generalizerRepeatPenalty,
              this.settings.generalizerMultiStage,
              this.settings.generalizerIntermediatePrompt
            );
          }
        }
      }
      new import_obsidian31.Notice("Wisdom Extraction Complete");
      this.next();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.next()));
  }
  stepFinalMerge(container) {
    new import_obsidian31.Setting(container).setName("Step 11: Final merge").setHeading();
    container.createEl("p", { text: `Merge all Wisdom files into a final output?` });
    new import_obsidian31.Setting(container).addButton((btn) => btn.setButtonText("Merge").setCta().onClick(async () => {
      let finalContent = "# Final Wisdom\n\n";
      const living = this.app.vault.getAbstractFileByPath(this.livingDir);
      for (const child of living.children) {
        if (child instanceof import_obsidian31.TFolder) {
          const wisdomPath = `${child.path}/${child.name}_Combined_Wisdom.md`;
          const file = this.app.vault.getAbstractFileByPath(wisdomPath);
          if (file instanceof import_obsidian31.TFile) {
            const content = await this.app.vault.read(file);
            finalContent += `## ${child.name}

${content}

`;
          }
        }
      }
      await this.app.vault.create(`${this.livingDir}/Final_Wisdom.md`, finalContent);
      new import_obsidian31.Notice("Final Merge Complete");
      this.leaf.detach();
    })).addButton((btn) => btn.setButtonText("Skip").onClick(() => this.leaf.detach()));
  }
};

// src/ui/yaml-template-modal.ts
var import_obsidian32 = require("obsidian");
var YamlTemplateModal = class extends import_obsidian32.Modal {
  constructor(app, settings, target) {
    super(app);
    this.recursive = true;
    this.addDate = true;
    this.service = new YamlTemplateService(app);
    this.target = target || null;
    this.template = settings.yamlTemplate || "date\nsummary\nsummary model\naudited\nrating";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian32.Setting(contentEl).setName("Apply YAML template").setHeading();
    if (this.target) {
      const type = this.target instanceof import_obsidian32.TFile ? "File" : "Folder";
      contentEl.createEl("p", { text: `Target: ${this.target.name} (${type})` });
    } else {
      contentEl.createEl("p", { text: "No target selected.", cls: "error-text" });
      return;
    }
    new import_obsidian32.Setting(contentEl).setName("Template fields").setDesc("One field per line. These will be ordered first.").addTextArea((text) => text.setValue(this.template).setPlaceholder("date\nsummary\ntags").onChange((v) => this.template = v));
    new import_obsidian32.Setting(contentEl).setName("Add date from filename").setDesc('If filename starts with YYYY-MM-DD, add it to "date" field').addToggle((t) => t.setValue(this.addDate).onChange((v) => this.addDate = v));
    if (!(this.target instanceof import_obsidian32.TFile)) {
      new import_obsidian32.Setting(contentEl).setName("Recursive").addToggle((t) => t.setValue(this.recursive).onChange((v) => this.recursive = v));
    }
    new import_obsidian32.Setting(contentEl).addButton((btn) => btn.setButtonText("Apply template").setCta().onClick(async () => {
      btn.setButtonText("Processing...").setDisabled(true);
      const order = this.template.split("\n").map((s) => s.trim()).filter((s) => s);
      try {
        if (this.target instanceof import_obsidian32.TFile) {
          await this.service.processFile(this.target, order, this.addDate);
          new import_obsidian32.Notice("YAML Updated");
        } else {
          const res = await this.service.processFolder(this.target.path, order, this.addDate, this.recursive);
          new import_obsidian32.Notice(`Processed: ${res.processed}, Errors: ${res.errors}`);
        }
        this.close();
      } catch (e) {
        new import_obsidian32.Notice("Error applying template");
        console.error(e);
        btn.setButtonText("Apply template").setDisabled(false);
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  // General
  ollamaUrl: "http://localhost:11434",
  // Wizard
  wizardInboxDir: "Inbox",
  wizardChronoDir: "Chrono",
  wizardLivingDir: "Living",
  // Atomizer
  atomizerDivider: "---",
  atomizerModel: "llama3",
  atomizerMode: "heading",
  // Summarizer
  summarizerModel: "llama3",
  summarizerRecursive: false,
  summarizerOverwrite: false,
  summarizerIncludeYaml: false,
  summarizerMaxChars: 5e4,
  summarizerPrompt: "Please summarise the following Markdown content from the file titled '{filename}':\n\n{text}",
  summarizerPrompt2: "You are a summarization assistant. Condense the following note into 50 words or fewer. Start directly with the main point and avoid phrases like 'This note', 'Key takeaways', 'It emphasizes', or any similar preamble. Use plain sentences only\u2014no headings, quotes, markdown, dates, filenames, or filler.\n\nTitle: {filename}\n\nLonger summary:\n{summary}",
  summarizerPrompt3: "Rewrite the following text keeping it at 50 words or fewer. Remove any filler, preambles (e.g., 'This note...', 'Key takeaways...'), dates, filenames, headings, markdown, or meta-language. Return only the cleaned summary text.\n\nText:\n{summary}",
  summarizerPrompt4: "Rewrite the following summary text, capitalizing the most important words, subjects, and key concepts. Keep all other text unchanged. Return only the rewritten text with capitalized important words.\n\nSummary:\n{summary}",
  summarizerGenerateTitle: true,
  // Automatic Rating
  ratingModel: "llama3",
  ratingParams: "coherence, profundity",
  ratingSkipIfRated: true,
  // YAML Template
  yamlTemplate: "date\nsummary\nsummary model\naudited\nrating",
  yamlAddDate: true,
  yamlRecursive: true,
  // Categorizer
  categorizerModel: "llama3",
  categorizerDictionaries: [
    {
      name: "Demo Dictionary",
      content: `Personal; Notes related to personal life
Work; Notes related to work
School; Notes related to school
Recipes; Cooking recipes`
    }
  ],
  categorizerActiveDictionary: "Demo Dictionary",
  categorizerApplyAsTag: true,
  categorizerApplyAsBacklink: false,
  categorizerMoveToFolder: false,
  categorizerMaxCategories: 1,
  // Date Fix
  dateFixRecursive: false,
  dateFixFallbackToCreationDate: false,
  dateFixDateFormat: "YYYY-MM-DD",
  dateFixExceptions: "*.py",
  // Chrono Merge
  chronoMergeTimeThreshold: 5,
  chronoMergeRecursive: false,
  chronoMergeUseCreationTime: false,
  // Deduplication
  deduplicationRecursive: true,
  // Parse and Move
  parseAndMoveTargetDir: "Parsed",
  parseAndMoveRecursive: false,
  // Generalizer
  generalizerModel: "llama3",
  generalizerPrompt: `You are a professional editor and wisdom extractor. Your task is to rewrite the following personal text into a piece of universal wisdom suitable for a general audience.
1. **Extract Wisdom**: Identify the core insights, lessons, and universal truths in the text.
2. **Generalize**: Remove all specific names, places, dates, and personally identifiable details. Replace them with general terms (e.g., replace "John" with "a friend", "Paris" with "a city").
3. **Relatability**: Ensure the tone is relatable and engaging for a public audience.
4. **Format**: Return ONLY the rewritten text. Do not include any preamble, explanations, or markdown code blocks.

Here is the text:
{text}`,
  generalizerSystemPrompt: 'You are a strict text-processing AI. Return ONLY the rewritten text. Do not include any preamble, introduction, explanation, or conclusion. Do not say "Here is the text". Do not summarize. Maintain the original language.',
  generalizerWisdomPrompt: `You are a world-renowned self-help author and philosopher. Your task is to rewrite the provided personal text into profound, universal wisdom.

### GUIDELINES:
1. **TRANSFORM**: Turn personal struggles into universal lessons on self-actualization and growth. Find the "silver lining".
2. **GENERALIZE**: STRICTLY REMOVE all specific names, dates, locations, and personally identifiable details. Replace them with general terms (e.g., "a friend", "a city").
3. **TONE**: Compassionate, insightful, and empowering.
4. **LANGUAGE**: Output must be in the same language as the input text.
5. **NO SUMMARIES**: Do not summarize. Rewrite the content as advice.

### INPUT TEXT:
{text}

### FINAL INSTRUCTION:
Rewrite the text above into universal wisdom.
- REMOVE ALL NAMES and specific details.
- Return ONLY the rewritten text.
- NO PREAMBLE.`,
  generalizerOutputMode: "folder",
  generalizerSuffix: "_generalized",
  generalizerMaxTokens: 8192,
  generalizerRepeatPenalty: 1.1,
  generalizerMultiStage: false,
  generalizerIntermediatePrompt: `You are a detailed summarizer. Your task is to create a comprehensive summary of the following text that retains ALL key details, emotional nuances, and specific events.
1. **Detail**: Do not make it brief. Capture the full essence of the narrative.
2. **Tone**: Maintain the original tone and perspective (first-person if applicable).
3. **Format**: Return ONLY the summary text. No preamble.

Here is the text:
{text}`,
  generalizerRecursive: false,
  // Wisdom
  wisdomModel: "llama3",
  wisdomMode: "advice",
  wisdomPrompt: "Extract wisdom from this text.",
  censorDictionaries: [
    {
      name: "Demo Dictionary",
      content: `John, Jon, Johnathon = Fernando
Jane = Mary
Bob, Robert = Ed`
    }
  ],
  censorActiveDictionary: "Demo Dictionary",
  censorReplacementChar: "\u2588",
  censorRecursive: false,
  censorOutputMode: "folder",
  censorSuffix: "_censored",
  // Concatonizer
  concatonizerRecursive: false,
  concatonizerSuffix: "_combined",
  concatonizerStripYaml: false,
  // Context Menu Visibility
  contextMenuDateFix: true,
  contextMenuMerge: true,
  contextMenuAtomize: true,
  contextMenuYamlTemplate: true,
  contextMenuSummarize: true,
  contextMenuCategorize: true,
  contextMenuParseAndMove: true,
  contextMenuDistill: true,
  contextMenuRating: true
};
var CoherencePlugin = class extends import_obsidian33.Plugin {
  async activateWizardView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_WIZARD);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_WIZARD, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async onload() {
    console.log("Coherence Plugin: Loaded version 0.0.22");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_WIZARD,
      (leaf) => new WizardView(leaf, this.app, this.settings)
    );
    this.addRibbonIcon("wand-2", "Coherence Wizard", (evt) => {
      this.activateWizardView();
    });
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Coherence Wizard Active");
    this.addCommand({
      id: "open-atomizer-modal",
      name: "Open Atomizer",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new AtomizerModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-summarizer-modal",
      name: "Open Summarizer",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new SummarizerModal(this.app, this.settings, async (key, value) => {
            this.settings[key] = value;
            await this.saveSettings();
          }, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-wisdom-modal",
      name: "Open Wisdom Extractor",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new WisdomModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-date-fix-modal",
      name: "Open Date Fix",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new DateFixModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-concatonizer-modal",
      name: "Open Concatonizer",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (file.parent) {
            new ConcatonizerModal(this.app, this.settings, file.parent).open();
          }
        } else {
          new import_obsidian33.Notice("No active file to determine folder.");
        }
      }
    });
    this.addCommand({
      id: "open-rating-modal",
      name: "Open Rating",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new RatingModal(this.app, this.settings, async (key, value) => {
            this.settings[key] = value;
            await this.saveSettings();
          }, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-categorizer-modal",
      name: "Open Categorizer",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new CategorizeHubModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-deduplication-modal",
      name: "Open Deduplication",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.parent) {
          new DeduplicationModal(this.app, file.parent).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-parse-and-move-modal",
      name: "Open Parse and Move",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new ParseAndMoveModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-censor-modal",
      name: "Open Censor and Alias",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          new CensorModal(this.app, this.settings, file).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-chrono-merge-modal",
      name: "Open Chrono Merge",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.parent) {
          new ChronoMergeModal(this.app, this.settings, file.parent).open();
        } else {
          new import_obsidian33.Notice("No active file.");
        }
      }
    });
    this.addCommand({
      id: "open-coherence-wizard",
      name: "Open Coherence Wizard",
      callback: () => {
        this.activateWizardView();
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (this.settings.contextMenuDateFix) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Date Fix").setIcon("calendar").onClick(async () => {
              new DateFixModal(this.app, this.settings, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuMerge) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Merge").setIcon("merge").onClick(async () => {
              new MergeModal(this.app, this.settings, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuAtomize) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Atomize").setIcon("scissors").onClick(async () => {
              new AtomizerModal(this.app, this.settings, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuYamlTemplate) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Apply YAML Template").setIcon("layout-template").onClick(async () => {
              new YamlTemplateModal(this.app, this.settings, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuSummarize) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Summarize").setIcon("lines-of-text").onClick(async () => {
              new SummarizerModal(this.app, this.settings, async (key, value) => {
                this.settings[key] = value;
                await this.saveSettings();
              }, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuCategorize) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Categorize").setIcon("folder").onClick(async () => {
              new CategorizeHubModal(this.app, this.settings, async (key, value) => {
                this.settings[key] = value;
                await this.saveSettings();
              }, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuParseAndMove) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Parse and Move").setIcon("folder-input").onClick(async () => {
              new ParseAndMoveModal(this.app, this.settings, view.file).open();
            });
          });
        }
        if (this.settings.contextMenuDistill) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Distill").setIcon("flask-conical").onClick(async () => {
              new DistillModal(this.app, this.settings, view.file).open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (this.settings.contextMenuDateFix) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Date Fix").setIcon("calendar").onClick(async () => {
              if (file instanceof import_obsidian33.TFile || file instanceof import_obsidian33.TFolder) {
                new DateFixModal(this.app, this.settings, file).open();
              }
            });
          });
        }
        if (this.settings.contextMenuMerge) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Merge").setIcon("merge").onClick(async () => {
              if (file instanceof import_obsidian33.TFile || file instanceof import_obsidian33.TFolder) {
                new MergeModal(this.app, this.settings, file).open();
              }
            });
          });
        }
        if (this.settings.contextMenuAtomize) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Atomize").setIcon("scissors").onClick(async () => {
              if (file instanceof import_obsidian33.TFile || file instanceof import_obsidian33.TFolder) {
                new AtomizerModal(this.app, this.settings, file).open();
              }
            });
          });
        }
        if (this.settings.contextMenuYamlTemplate) {
          menu.addItem((item) => {
            item.setTitle("Coherence: Apply YAML Template").setIcon("layout-template").onClick(async () => {
              if (file instanceof import_obsidian33.TFile || file instanceof import_obsidian33.TFolder) {
                new YamlTemplateModal(this.app, this.settings, file).open();
              }
            });
          });
        }
        if (file instanceof import_obsidian33.TFile || file instanceof import_obsidian33.TFolder) {
          if (this.settings.contextMenuSummarize) {
            menu.addItem((item) => {
              item.setTitle("Coherence: Summarize").setIcon("lines-of-text").onClick(async () => {
                new SummarizerModal(this.app, this.settings, async (key, value) => {
                  this.settings[key] = value;
                  await this.saveSettings();
                }, file).open();
              });
            });
          }
          if (this.settings.contextMenuCategorize) {
            menu.addItem((item) => {
              item.setTitle("Coherence: Categorize").setIcon("folder").onClick(async () => {
                new CategorizeHubModal(this.app, this.settings, async (key, value) => {
                  this.settings[key] = value;
                  await this.saveSettings();
                }, file).open();
              });
            });
          }
          if (this.settings.contextMenuParseAndMove) {
            menu.addItem((item) => {
              item.setTitle("Coherence: Parse and Move").setIcon("folder-input").onClick(async () => {
                new ParseAndMoveModal(this.app, this.settings, file).open();
              });
            });
          }
          if (this.settings.contextMenuDistill) {
            menu.addItem((item) => {
              item.setTitle("Coherence: Distill").setIcon("flask-conical").onClick(async () => {
                new DistillModal(this.app, this.settings, file).open();
              });
            });
          }
        }
      })
    );
    this.addSettingTab(new CoherenceSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CoherenceSettingTab = class extends import_obsidian33.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "about";
    this.ollamaModels = [];
    this.plugin = plugin;
  }
  async fetchModels() {
    try {
      const ollama = new OllamaService(this.plugin.settings.ollamaUrl);
      this.ollamaModels = await ollama.listModels();
      if (this.ollamaModels.length === 0) {
        this.ollamaModels = ["llama3", "mistral", "gemma"];
      }
    } catch (e) {
      console.error("Failed to fetch models", e);
      this.ollamaModels = ["llama3", "mistral", "gemma"];
    }
  }
  async display() {
    console.log("Coherence Settings: Displaying tab", this.activeTab);
    await this.fetchModels();
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Coherence Wizard Settings" });
    const navContainer = containerEl.createDiv({ cls: "settings-nav-container" });
    navContainer.style.display = "flex";
    navContainer.style.flexWrap = "wrap";
    navContainer.style.marginBottom = "20px";
    navContainer.style.gap = "10px";
    const tabs = [
      { id: "about", name: "About" },
      { id: "contextmenu", name: "Context Menu" },
      { id: "datefix", name: "Date Fix" },
      { id: "merge", name: "Merge" },
      { id: "atomizer", name: "Atomization" },
      { id: "yaml", name: "YAML Template" },
      { id: "summarizer", name: "Summarize" },
      { id: "categorizer", name: "Categorize" },
      { id: "parsemove", name: "Parse & Move" },
      { id: "parsemove", name: "Parse & Move" },
      { id: "distill", name: "Distill" },
      { id: "rating", name: "Rating" },
      { id: "wizard", name: "Coherence Wizard" }
    ];
    tabs.forEach((tab) => {
      const btn = navContainer.createEl("button", { text: tab.name });
      if (this.activeTab === tab.id) {
        btn.addClass("mod-cta");
      }
      btn.onclick = () => {
        this.activeTab = tab.id;
        this.display();
      };
    });
    try {
      if (this.activeTab === "about") {
        this.renderAboutSettings(containerEl);
      } else if (this.activeTab === "wizard") {
        this.renderWizardSettings(containerEl);
      } else if (this.activeTab === "rating") {
        this.renderRatingSettings(containerEl);
      } else if (this.activeTab === "contextmenu") {
        console.log("Rendering Context Menu Settings (Inlined)");
        containerEl.createEl("h2", { text: "Context Menu Settings" });
        containerEl.createEl("p", { text: "Select which features should appear in the right-click context menu." });
        new import_obsidian33.Setting(containerEl).setName("Date Fix").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuDateFix).onChange(async (value) => {
          this.plugin.settings.contextMenuDateFix = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Merge").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuMerge).onChange(async (value) => {
          this.plugin.settings.contextMenuMerge = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Atomize").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuAtomize).onChange(async (value) => {
          this.plugin.settings.contextMenuAtomize = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("YAML Template").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuYamlTemplate).onChange(async (value) => {
          this.plugin.settings.contextMenuYamlTemplate = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Summarize").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuSummarize).onChange(async (value) => {
          this.plugin.settings.contextMenuSummarize = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Categorize").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuCategorize).onChange(async (value) => {
          this.plugin.settings.contextMenuCategorize = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Parse and Move").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuParseAndMove).onChange(async (value) => {
          this.plugin.settings.contextMenuParseAndMove = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian33.Setting(containerEl).setName("Distill").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuDistill).onChange(async (value) => {
          this.plugin.settings.contextMenuDistill = value;
          await this.plugin.saveSettings();
        }));
      } else if (this.activeTab === "datefix") {
        this.renderDateFixSettings(containerEl);
      } else if (this.activeTab === "merge") {
        this.renderMergeSettings(containerEl);
      } else if (this.activeTab === "atomizer") {
        this.renderAtomizerSettings(containerEl);
      } else if (this.activeTab === "yaml") {
        this.renderYamlSettings(containerEl);
      } else if (this.activeTab === "summarizer") {
        this.renderSummarizerSettings(containerEl);
      } else if (this.activeTab === "categorizer") {
        this.renderCategorizerSettings(containerEl);
      } else if (this.activeTab === "parsemove") {
        this.renderParseAndMoveSettings(containerEl);
      } else if (this.activeTab === "distill") {
        this.renderDistillSettings(containerEl);
      }
    } catch (e) {
      console.error("Error rendering settings tab:", e);
      containerEl.createEl("p", { text: "Error rendering settings. Please check console." });
    }
  }
  renderAboutSettings(containerEl) {
    containerEl.createEl("h2", { text: "About Coherence Wizard" });
    containerEl.createEl("p", { text: "Version: 0.0.22", cls: "version-text" });
    containerEl.createEl("p", { text: "The intention is to streamline coherence by using tools to convert chaos into order." });
    containerEl.createEl("p", { text: "The included tools have significantly enhanced my PKM workflows and I want to help others passionate about self-development using Obsidian." });
    containerEl.createEl("p", { text: "Many of these tools rely on private local AI via Ollama. (Future iterations of this plugin will allow for the use of large cloud AI via API). This is a privacy first plugin." });
    const warning = containerEl.createEl("p");
    warning.createEl("strong", { text: "Many people without GPUs or large CPUs will struggle to use local models large enough to generate quality output. Without GPU, local AI models will be slow and potentially laggy. So use this beta plugin at your own risk. I recommend testing on a test vault or a test folder to see how all the tools work." });
    containerEl.createEl("p", { text: "You will need to install Ollama on your computer and pull your favorite local AI models. I recommend gemma3:12b-it-qat if your computer can handle it. Otherwise gemma3:4b-it-qat for constrained resources." });
    const bmcContainer = containerEl.createDiv();
    bmcContainer.style.marginTop = "20px";
    bmcContainer.style.marginBottom = "20px";
    const bmcLink = bmcContainer.createEl("a", { href: "https://www.buymeacoffee.com/rastovich" });
    const bmcImg = bmcLink.createEl("img", {
      attr: {
        src: "https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=rastovich&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff",
        alt: "Buy me a coffee"
      }
    });
    bmcImg.style.height = "40px";
    containerEl.createEl("h3", { text: "Configuration" });
    new import_obsidian33.Setting(containerEl).setName("Ollama URL").setDesc("URL of your local Ollama instance").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaUrl).onChange(async (value) => {
      this.plugin.settings.ollamaUrl = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("p", { text: "Next go through each of the settings tabs to review settings." });
    containerEl.createEl("p", { text: "Settings which particularly need your attention are the ones for YAML Template, Categorize and Distill." });
    containerEl.createEl("p", { text: "These require dictionaries you need to create that match your workflow." });
    containerEl.createEl("p", { text: "What YAML keys do you want to include? What order are these keys?" });
    containerEl.createEl("p", { text: "How do you want to categorize your notes? What topics do you cover? Beware that the more categories you include in your dictionary, the less accurate category selection will be. Perhaps start with something like:" });
    const catList = containerEl.createEl("ul");
    catList.createEl("li", { text: "Work" });
    catList.createEl("li", { text: "Personal" });
    containerEl.createEl("p", { text: 'There are several tools under "Distill" which prepare your notes for expression with a general audience. This also includes a way to convert names and places to aliases. You need to create a dictionary that includes the names and places you want to obscure (along with their mispellings and abbreviations) along with the replacement word. For example:' });
    const aliasList = containerEl.createEl("ul");
    aliasList.createEl("li", { text: "John, Jon, Joan, Johnathon, Johnny = Bob" });
    containerEl.createEl("p", { text: "Each settings tab will explain what each function does." });
    containerEl.createEl("h3", { text: "Support" });
    containerEl.createEl("p", { text: 'If this app benefits you and want to encourage me to develop these and other tools. Please consider "Buying Me A Coffee" which would go a long way in encouraging me!' });
    containerEl.createEl("p", { text: "If this tool saves you just one hour of time per month, please consider donating or subscribing!" });
  }
  renderContextMenuSettings(containerEl) {
    console.log("Rendering Context Menu Settings");
    containerEl.createEl("h2", { text: "Context Menu Settings" });
    containerEl.createEl("p", { text: "Select which features should appear in the right-click context menu." });
    new import_obsidian33.Setting(containerEl).setName("Date Fix").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuDateFix).onChange(async (value) => {
      this.plugin.settings.contextMenuDateFix = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Merge").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuMerge).onChange(async (value) => {
      this.plugin.settings.contextMenuMerge = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Atomize").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuAtomize).onChange(async (value) => {
      this.plugin.settings.contextMenuAtomize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("YAML Template").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuYamlTemplate).onChange(async (value) => {
      this.plugin.settings.contextMenuYamlTemplate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Summarize").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuSummarize).onChange(async (value) => {
      this.plugin.settings.contextMenuSummarize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Categorize").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuCategorize).onChange(async (value) => {
      this.plugin.settings.contextMenuCategorize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Parse and Move").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuParseAndMove).onChange(async (value) => {
      this.plugin.settings.contextMenuParseAndMove = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Distill").setDesc("Available in: File").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuDistill).onChange(async (value) => {
      this.plugin.settings.contextMenuDistill = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Rating").setDesc("Available in: File, Folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.contextMenuRating).onChange(async (value) => {
      this.plugin.settings.contextMenuRating = value;
      await this.plugin.saveSettings();
    }));
  }
  renderAtomizerSettings(containerEl) {
    containerEl.createEl("h2", { text: "Atomizer Settings" });
    const desc = containerEl.createDiv({ cls: "setting-item-description" });
    desc.style.marginBottom = "20px";
    desc.innerHTML = `
            <p><strong>Atomization Modes:</strong></p>
            <ul>
                <li><strong>By Heading:</strong> Splits the file based on markdown headings (H1, H2, etc.). Each section becomes a new file.</li>
                <li><strong>By ISO Date:</strong> Splits the file based on ISO 8601 date patterns found in the text (e.g. YYYY-MM-DD). Useful for splitting daily logs.</li>
                <li><strong>By Divider:</strong> Splits the file using a custom divider string (e.g. '---').</li>
            </ul>
        `;
    new import_obsidian33.Setting(containerEl).setName("Default Divider").setDesc('The default divider string for "By Divider" mode').addText((text) => text.setPlaceholder("---").setValue(this.plugin.settings.atomizerDivider).onChange(async (value) => {
      this.plugin.settings.atomizerDivider = value;
      await this.plugin.saveSettings();
    }));
  }
  renderSummarizerSettings(containerEl) {
    containerEl.createEl("h2", { text: "Summarizer Settings" });
    new import_obsidian33.Setting(containerEl).setName("Default Model").setDesc("Ollama model to use for summarization").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.summarizerModel)) {
        drop.addOption(this.plugin.settings.summarizerModel, this.plugin.settings.summarizerModel);
      }
      drop.setValue(this.plugin.settings.summarizerModel).onChange(async (value) => {
        this.plugin.settings.summarizerModel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Recursive Processing").setDesc("Process subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.summarizerRecursive).onChange(async (value) => {
      this.plugin.settings.summarizerRecursive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Overwrite Existing").setDesc("Overwrite existing summaries by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.summarizerOverwrite).onChange(async (value) => {
      this.plugin.settings.summarizerOverwrite = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Include YAML").setDesc("Include YAML frontmatter in the input sent to the model").addToggle((toggle) => toggle.setValue(this.plugin.settings.summarizerIncludeYaml).onChange(async (value) => {
      this.plugin.settings.summarizerIncludeYaml = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Max Characters").setDesc("Maximum characters to process per file").addText((text) => text.setValue(String(this.plugin.settings.summarizerMaxChars)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num)) {
        this.plugin.settings.summarizerMaxChars = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian33.Setting(containerEl).setName("Auto-Generate Title").setDesc("Append AI-generated title to filename (useful for Untitled or Daily Notes)").addToggle((toggle) => toggle.setValue(this.plugin.settings.summarizerGenerateTitle).onChange(async (value) => {
      this.plugin.settings.summarizerGenerateTitle = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Progressive Sequential Summarization Prompts" });
    new import_obsidian33.Setting(containerEl).setName("Prompt 1 (General Summary)").setDesc("Initial comprehensive summary. Placeholders: {filename}, {text}").addTextArea((text) => text.setValue(this.plugin.settings.summarizerPrompt).setPlaceholder("Enter prompt...").then((t) => t.inputEl.rows = 6).onChange(async (value) => {
      this.plugin.settings.summarizerPrompt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Prompt 2 (Concise Summary)").setDesc("Condense the summary. Placeholders: {filename}, {summary}").addTextArea((text) => text.setValue(this.plugin.settings.summarizerPrompt2).setPlaceholder("Enter prompt...").then((t) => t.inputEl.rows = 6).onChange(async (value) => {
      this.plugin.settings.summarizerPrompt2 = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Prompt 3 (De-fluff)").setDesc("Remove filler. Placeholders: {summary}").addTextArea((text) => text.setValue(this.plugin.settings.summarizerPrompt3).setPlaceholder("Enter prompt...").then((t) => t.inputEl.rows = 6).onChange(async (value) => {
      this.plugin.settings.summarizerPrompt3 = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Prompt 4 (Capitalize)").setDesc("Capitalize important words. Placeholders: {summary}").addTextArea((text) => text.setValue(this.plugin.settings.summarizerPrompt4).setPlaceholder("Enter prompt...").then((t) => t.inputEl.rows = 6).onChange(async (value) => {
      this.plugin.settings.summarizerPrompt4 = value;
      await this.plugin.saveSettings();
    }));
  }
  renderYamlSettings(containerEl) {
    containerEl.createEl("h2", { text: "YAML Template Settings" });
    const desc = containerEl.createDiv({ cls: "setting-item-description" });
    desc.style.marginBottom = "20px";
    desc.innerHTML = `
            <p><strong>Note:</strong></p>
            <ul>
                <li>Any YAML keys that are not in the template will be preserved and added after the main template keys.</li>
                <li>Existing values for keys in the template will be preserved but reordered.</li>
            </ul>
        `;
    new import_obsidian33.Setting(containerEl).setName("Default Template").setDesc("Default fields for YAML template (one per line)").addTextArea((text) => {
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.setValue(this.plugin.settings.yamlTemplate).onChange(async (value) => {
        this.plugin.settings.yamlTemplate = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Add Date From Filename").setDesc('If filename starts with YYYY-MM-DD, add it to "date" field').addToggle((toggle) => toggle.setValue(this.plugin.settings.yamlAddDate).onChange(async (value) => {
      this.plugin.settings.yamlAddDate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders when running on a folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.yamlRecursive).onChange(async (value) => {
      this.plugin.settings.yamlRecursive = value;
      await this.plugin.saveSettings();
    }));
  }
  renderCategorizerSettings(containerEl) {
    containerEl.createEl("h2", { text: "Categorizer Settings" });
    new import_obsidian33.Setting(containerEl).setName("Categorizer Model").setDesc("The Ollama model to use for categorization").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.categorizerModel)) {
        drop.addOption(this.plugin.settings.categorizerModel, this.plugin.settings.categorizerModel);
      }
      drop.setValue(this.plugin.settings.categorizerModel).onChange(async (value) => {
        this.plugin.settings.categorizerModel = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Dictionaries" });
    const dictDesc = containerEl.createDiv({ cls: "setting-item-description" });
    dictDesc.style.marginBottom = "10px";
    dictDesc.innerHTML = `
            <p><strong>Dictionary Syntax:</strong></p>
            <p>Each line represents a category. You can optionally provide a description after a semicolon.</p>
            <pre>Category Name; Description of the category</pre>
            <p>Example:</p>
            <pre>Personal; Notes related to personal life
Work; Job related tasks and projects</pre>
        `;
    const dictSetting = new import_obsidian33.Setting(containerEl).setName("Active Dictionary").setDesc("Select, rename, or delete dictionaries").addDropdown((drop) => {
      this.plugin.settings.categorizerDictionaries.forEach((d) => drop.addOption(d.name, d.name));
      drop.setValue(this.plugin.settings.categorizerActiveDictionary).onChange(async (value) => {
        this.plugin.settings.categorizerActiveDictionary = value;
        await this.plugin.saveSettings();
        this.display();
      });
    }).addExtraButton((btn) => btn.setIcon("plus").setTooltip("Add New Dictionary").onClick(async () => {
      let name = "New Dictionary";
      let i = 1;
      while (this.plugin.settings.categorizerDictionaries.some((d) => d.name === name)) {
        name = `New Dictionary ${i++}`;
      }
      this.plugin.settings.categorizerDictionaries.push({ name, content: "" });
      this.plugin.settings.categorizerActiveDictionary = name;
      await this.plugin.saveSettings();
      this.display();
    })).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Dictionary").onClick(async () => {
      if (this.plugin.settings.categorizerDictionaries.length <= 1) {
        new import_obsidian33.Notice("Cannot delete the last dictionary.");
        return;
      }
      this.plugin.settings.categorizerDictionaries = this.plugin.settings.categorizerDictionaries.filter((d) => d.name !== this.plugin.settings.categorizerActiveDictionary);
      this.plugin.settings.categorizerActiveDictionary = this.plugin.settings.categorizerDictionaries[0].name;
      await this.plugin.saveSettings();
      this.display();
    }));
    const activeDict = this.plugin.settings.categorizerDictionaries.find((d) => d.name === this.plugin.settings.categorizerActiveDictionary);
    if (activeDict) {
      new import_obsidian33.Setting(containerEl).setName("Rename Dictionary").addText((text) => text.setValue(activeDict.name).onChange(async (value) => {
        if (value && value !== activeDict.name) {
          if (this.plugin.settings.categorizerDictionaries.some((d) => d.name === value)) {
            new import_obsidian33.Notice("Dictionary name already exists.");
            return;
          }
          activeDict.name = value;
          this.plugin.settings.categorizerActiveDictionary = value;
          await this.plugin.saveSettings();
        }
      })).addExtraButton((btn) => btn.setIcon("check").setTooltip("Apply Rename (Refresh)").onClick(() => this.display()));
      new import_obsidian33.Setting(containerEl).setName("Dictionary Content").setDesc("Edit the categories for the selected dictionary").addTextArea((text) => {
        text.inputEl.rows = 15;
        text.inputEl.style.width = "100%";
        text.setValue(activeDict.content).onChange(async (value) => {
          activeDict.content = value;
          await this.plugin.saveSettings();
        });
      });
    }
    containerEl.createEl("h3", { text: "Default Options" });
    new import_obsidian33.Setting(containerEl).setName("Apply as Tag").setDesc("Add category as #tag in YAML").addToggle((toggle) => toggle.setValue(this.plugin.settings.categorizerApplyAsTag).onChange(async (value) => {
      this.plugin.settings.categorizerApplyAsTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Apply as Backlink").setDesc("Append category as [[backlink]] at end of file").addToggle((toggle) => toggle.setValue(this.plugin.settings.categorizerApplyAsBacklink).onChange(async (value) => {
      this.plugin.settings.categorizerApplyAsBacklink = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Move to Folder").setDesc("Move file to a subfolder named after the category").addToggle((toggle) => toggle.setValue(this.plugin.settings.categorizerMoveToFolder).onChange(async (value) => {
      this.plugin.settings.categorizerMoveToFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Max Categories").setDesc("Maximum number of categories to apply (default 1)").addText((text) => text.setValue(String(this.plugin.settings.categorizerMaxCategories)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.categorizerMaxCategories = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h2", { text: "Automatic Rating Settings" });
    new import_obsidian33.Setting(containerEl).setName("Default Model").setDesc("Ollama model to use for rating").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.ratingModel)) {
        drop.addOption(this.plugin.settings.ratingModel, this.plugin.settings.ratingModel);
      }
      drop.setValue(this.plugin.settings.ratingModel).onChange(async (value) => {
        this.plugin.settings.ratingModel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Quality Parameters").setDesc("Comma separated list of quality parameters").addText((text) => text.setValue(this.plugin.settings.ratingParams).onChange(async (value) => {
      this.plugin.settings.ratingParams = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Skip Existing").setDesc("Skip files that already have a rating in YAML").addToggle((toggle) => toggle.setValue(this.plugin.settings.ratingSkipIfRated).onChange(async (value) => {
      this.plugin.settings.ratingSkipIfRated = value;
      await this.plugin.saveSettings();
    }));
  }
  renderWizardSettings(containerEl) {
    containerEl.createEl("h2", { text: "Coherence Wizard Settings" });
    containerEl.createEl("p", { text: "Configure the folders used by the One Click Coherence Wizard." });
    new import_obsidian33.Setting(containerEl).setName("Inbox Folder").setDesc("Folder containing new notes to process").addText((text) => text.setValue(this.plugin.settings.wizardInboxDir).onChange(async (value) => {
      this.plugin.settings.wizardInboxDir = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Chrono Folder").setDesc("Folder for chronological storage (archive)").addText((text) => text.setValue(this.plugin.settings.wizardChronoDir).onChange(async (value) => {
      this.plugin.settings.wizardChronoDir = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Living Folder").setDesc("Folder for living documents (categorized)").addText((text) => text.setValue(this.plugin.settings.wizardLivingDir).onChange(async (value) => {
      this.plugin.settings.wizardLivingDir = value;
      await this.plugin.saveSettings();
    }));
  }
  renderDateFixSettings(containerEl) {
    containerEl.createEl("h2", { text: "Date Fix Settings" });
    containerEl.createEl("p", { text: "This tool standardizes filenames by ensuring they start with a date in the preferred format. It automatically detects and converts existing dates or date-like number strings (e.g. 20220221) found in the filename.", cls: "setting-item-description" });
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.dateFixRecursive).onChange(async (value) => {
      this.plugin.settings.dateFixRecursive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Fallback to Creation Date").setDesc("If no date is found in the filename, prepend the file's creation date.").addToggle((toggle) => toggle.setValue(this.plugin.settings.dateFixFallbackToCreationDate).onChange(async (value) => {
      this.plugin.settings.dateFixFallbackToCreationDate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Preferred Date Format").setDesc("ISO format to use (e.g. YYYY-MM-DD)").addText((text) => text.setValue(this.plugin.settings.dateFixDateFormat).onChange(async (value) => {
      this.plugin.settings.dateFixDateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Exceptions").setDesc("Comma separated list of file extensions (e.g. *.py) or words to exclude").addTextArea((text) => text.setValue(this.plugin.settings.dateFixExceptions).onChange(async (value) => {
      this.plugin.settings.dateFixExceptions = value;
      await this.plugin.saveSettings();
    }));
  }
  renderParseAndMoveSettings(containerEl) {
    containerEl.createEl("h2", { text: "Parse and Move Settings" });
    new import_obsidian33.Setting(containerEl).setName("Target Directory").setDesc("Directory to move parsed files to").addText((text) => text.setValue(this.plugin.settings.parseAndMoveTargetDir).onChange(async (value) => {
      this.plugin.settings.parseAndMoveTargetDir = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.parseAndMoveRecursive).onChange(async (value) => {
      this.plugin.settings.parseAndMoveRecursive = value;
      await this.plugin.saveSettings();
    }));
  }
  renderDistillSettings(containerEl) {
    containerEl.createEl("h2", { text: "Distill Settings" });
    containerEl.createEl("h3", { text: "Censor / Alias" });
    const dictDesc = containerEl.createDiv({ cls: "setting-item-description" });
    dictDesc.style.marginBottom = "10px";
    dictDesc.innerHTML = `
            <p><strong>Dictionary Syntax:</strong></p>
            <p>Each line represents a word/phrase to censor.</p>
        `;
    new import_obsidian33.Setting(containerEl).setName("Active Dictionary").setDesc("Select dictionary for censorship").addDropdown((drop) => {
      this.plugin.settings.censorDictionaries.forEach((d) => drop.addOption(d.name, d.name));
      drop.setValue(this.plugin.settings.censorActiveDictionary).onChange(async (value) => {
        this.plugin.settings.censorActiveDictionary = value;
        await this.plugin.saveSettings();
        this.display();
      });
    }).addExtraButton((btn) => btn.setIcon("plus").setTooltip("Add New Dictionary").onClick(async () => {
      let name = "New Dictionary";
      let i = 1;
      while (this.plugin.settings.censorDictionaries.some((d) => d.name === name)) {
        name = `New Dictionary ${i++}`;
      }
      this.plugin.settings.censorDictionaries.push({ name, content: "" });
      this.plugin.settings.censorActiveDictionary = name;
      await this.plugin.saveSettings();
      this.display();
    })).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Dictionary").onClick(async () => {
      if (this.plugin.settings.censorDictionaries.length <= 1) {
        new import_obsidian33.Notice("Cannot delete the last dictionary.");
        return;
      }
      this.plugin.settings.censorDictionaries = this.plugin.settings.censorDictionaries.filter((d) => d.name !== this.plugin.settings.censorActiveDictionary);
      this.plugin.settings.censorActiveDictionary = this.plugin.settings.censorDictionaries[0].name;
      await this.plugin.saveSettings();
      this.display();
    }));
    const activeDict = this.plugin.settings.censorDictionaries.find((d) => d.name === this.plugin.settings.censorActiveDictionary);
    if (activeDict) {
      new import_obsidian33.Setting(containerEl).setName("Rename Dictionary").addText((text) => text.setValue(activeDict.name).onChange(async (value) => {
        if (value && value !== activeDict.name) {
          if (this.plugin.settings.censorDictionaries.some((d) => d.name === value)) {
            new import_obsidian33.Notice("Dictionary name already exists.");
            return;
          }
          activeDict.name = value;
          this.plugin.settings.censorActiveDictionary = value;
          await this.plugin.saveSettings();
        }
      })).addExtraButton((btn) => btn.setIcon("check").setTooltip("Apply Rename (Refresh)").onClick(() => this.display()));
      new import_obsidian33.Setting(containerEl).setName("Dictionary Content").setDesc("Edit the censored words (one per line)").addTextArea((text) => {
        text.inputEl.rows = 10;
        text.inputEl.style.width = "100%";
        text.setValue(activeDict.content).onChange(async (value) => {
          activeDict.content = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian33.Setting(containerEl).setName("Replacement Character").setDesc("Character to replace censored words with").addText((text) => text.setValue(this.plugin.settings.censorReplacementChar).onChange(async (value) => {
      this.plugin.settings.censorReplacementChar = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders").addToggle((toggle) => toggle.setValue(this.plugin.settings.censorRecursive).onChange(async (value) => {
      this.plugin.settings.censorRecursive = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Generalize" });
    new import_obsidian33.Setting(containerEl).setName("Model").setDesc("Ollama model to use").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.generalizerModel)) {
        drop.addOption(this.plugin.settings.generalizerModel, this.plugin.settings.generalizerModel);
      }
      drop.setValue(this.plugin.settings.generalizerModel).onChange(async (value) => {
        this.plugin.settings.generalizerModel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("System Prompt").setDesc("System prompt for the model").addTextArea((text) => text.setValue(this.plugin.settings.generalizerSystemPrompt).onChange(async (value) => {
      this.plugin.settings.generalizerSystemPrompt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Prompt").setDesc("Prompt template. Use {text} as placeholder.").addTextArea((text) => text.setValue(this.plugin.settings.generalizerPrompt).onChange(async (value) => {
      this.plugin.settings.generalizerPrompt = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Wisdom Extractor" });
    new import_obsidian33.Setting(containerEl).setName("Default Model").setDesc("Ollama model to use for wisdom extraction").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.wisdomModel)) {
        drop.addOption(this.plugin.settings.wisdomModel, this.plugin.settings.wisdomModel);
      }
      drop.setValue(this.plugin.settings.wisdomModel).onChange(async (value) => {
        this.plugin.settings.wisdomModel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Default Mode").setDesc("Default processing mode").addDropdown((drop) => drop.addOption("generalized", "Generalized (AI)").addOption("safe", "Safe (Copy Only)").setValue(this.plugin.settings.wisdomMode).onChange(async (value) => {
      this.plugin.settings.wisdomMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Wisdom Prompt").setDesc("The prompt template used for wisdom extraction").addTextArea((text) => text.setValue(this.plugin.settings.wisdomPrompt).onChange(async (value) => {
      this.plugin.settings.wisdomPrompt = value;
      await this.plugin.saveSettings();
    }));
  }
  renderMergeSettings(containerEl) {
    containerEl.createEl("h2", { text: "Merge Settings" });
    containerEl.createEl("h3", { text: "Chrono Merge" });
    new import_obsidian33.Setting(containerEl).setName("Time Threshold (Minutes)").setDesc("Files created within this time window will be merged").addText((text) => text.setValue(String(this.plugin.settings.chronoMergeTimeThreshold)).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) {
        this.plugin.settings.chronoMergeTimeThreshold = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian33.Setting(containerEl).setName("Use File Creation Time").setDesc("If enabled, uses the file's creation date property instead of the date in the filename.").addToggle((toggle) => toggle.setValue(this.plugin.settings.chronoMergeUseCreationTime).onChange(async (value) => {
      this.plugin.settings.chronoMergeUseCreationTime = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.chronoMergeRecursive).onChange(async (value) => {
      this.plugin.settings.chronoMergeRecursive = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Concatonizer" });
    new import_obsidian33.Setting(containerEl).setName("Filename Suffix").setDesc("Suffix to append to the folder name for the combined file (default: _combined)").addText((text) => text.setValue(this.plugin.settings.concatonizerSuffix).onChange(async (value) => {
      this.plugin.settings.concatonizerSuffix = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Include subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.concatonizerRecursive).onChange(async (value) => {
      this.plugin.settings.concatonizerRecursive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Strip YAML").setDesc("Remove YAML frontmatter from combined files").addToggle((toggle) => toggle.setValue(this.plugin.settings.concatonizerStripYaml).onChange(async (value) => {
      this.plugin.settings.concatonizerStripYaml = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Deduplication" });
    new import_obsidian33.Setting(containerEl).setName("Recursive").setDesc("Process subfolders by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.deduplicationRecursive).onChange(async (value) => {
      this.plugin.settings.deduplicationRecursive = value;
      await this.plugin.saveSettings();
    }));
  }
  renderRatingSettings(containerEl) {
    containerEl.createEl("h2", { text: "Automatic Rating Settings" });
    new import_obsidian33.Setting(containerEl).setName("Default Model").setDesc("Ollama model to use for rating").addDropdown((drop) => {
      this.ollamaModels.forEach((model) => drop.addOption(model, model));
      if (!this.ollamaModels.includes(this.plugin.settings.ratingModel)) {
        drop.addOption(this.plugin.settings.ratingModel, this.plugin.settings.ratingModel);
      }
      drop.setValue(this.plugin.settings.ratingModel).onChange(async (value) => {
        this.plugin.settings.ratingModel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Quality Parameters").setDesc("Comma separated list of parameters to rate (e.g. coherence, profundity)").addText((text) => text.setValue(this.plugin.settings.ratingParams).onChange(async (value) => {
      this.plugin.settings.ratingParams = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian33.Setting(containerEl).setName("Skip Rated").setDesc("Skip files that already have a rating in frontmatter").addToggle((toggle) => toggle.setValue(this.plugin.settings.ratingSkipIfRated).onChange(async (value) => {
      this.plugin.settings.ratingSkipIfRated = value;
      await this.plugin.saveSettings();
    }));
  }
};
